{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyWavelets - Wavelet Transforms in Python","text":""},{"location":"#contents","title":"Contents","text":"<p>PyWavelets is open source wavelet transform software for Python_. It combines a simple high level interface with low level C and Cython performance.</p> <p>PyWavelets is very easy to use and get started with. Just install the package, open the Python interactive shell and type:</p> <pre><code>import pywt\ncA, cD = pywt.dwt([1, 2, 3, 4], 'db1')\n</code></pre> <p>Voil\u00e0! Computing wavelet transforms has never been so simple :)</p> <p>Here is a slightly more involved example of applying a digital wavelet transform to an image:</p> <pre><code># mkdocs: render\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport pywt\nimport pywt.data\n\n# Load image\noriginal = pywt.data.camera()\n\n# Wavelet transform of image, and plot approximation and details\ntitles = ['Approximation', ' Horizontal detail',\n          'Vertical detail', 'Diagonal detail']\ncoeffs2 = pywt.dwt2(original, 'bior1.3')\nLL, (LH, HL, HH) = coeffs2\nfig = plt.figure(figsize=(12, 3))\nfor i, a in enumerate([LL, LH, HL, HH]):\n    ax = fig.add_subplot(1, 4, i + 1)\n    ax.imshow(a, interpolation=\"nearest\", cmap=plt.cm.gray)\n    ax.set_title(titles[i], fontsize=10)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\nfig.tight_layout()\n</code></pre>"},{"location":"#main-features","title":"Main features","text":"<p>The main features of PyWavelets are:</p> <ul> <li>1D, 2D and nD Forward and Inverse Discrete Wavelet Transform (DWT and IDWT)</li> <li>1D, 2D and nD Multilevel DWT and IDWT</li> <li>1D, 2D and nD Stationary Wavelet Transform (Undecimated Wavelet Transform)</li> <li>1D and 2D Wavelet Packet decomposition and reconstruction</li> <li>1D Continuous Wavelet Transform</li> <li>Computing Approximations of wavelet and scaling functions</li> <li>Over 100 <code>built-in wavelet filters</code>_ and support for custom wavelets</li> <li>Single and double precision calculations</li> <li>Real and complex calculations</li> <li>Results compatible with Matlab Wavelet Toolbox (TM)</li> </ul>"},{"location":"#getting-help","title":"Getting help","text":"<p>Use GitHub Issues, StackOverflow, or the PyWavelets discussions group to post your comments or questions.</p>"},{"location":"#license","title":"License","text":"<p>PyWavelets is a free Open Source software released under the MIT license.</p>"},{"location":"#citing","title":"Citing","text":"<p>If you use PyWavelets in a scientific publication, we would appreciate citations of the project via the following JOSS publication:</p> <p>Gregory R. Lee, Ralf Gommers, Filip Wasilewski, Kai Wohlfahrt, Aaron O'Leary (2019). PyWavelets: A Python package for wavelet analysis. Journal of Open Source Software, 4(36), 1237, https://doi.org/10.21105/joss.01237.</p> <p></p> <p>Specific releases can also be cited via Zenodo. The DOI below will correspond to the most recent release. DOIs for past versions can be found by following the link in the badge below to Zenodo:</p> <p></p>"},{"location":"install/","title":"Installing","text":"<p>The latest release, including binary packages for Windows, macOS and Linux, is available for download from PyPI. You can also find source releases at the Releases Page.</p> <p>You can install PyWavelets with::</p> <pre><code>pip install PyWavelets\n</code></pre> <p>Users of the <code>conda</code> may wish to obtain pre-built Windows, Intel Linux or macOS/OSX binaries from the main or conda-forge channel::</p> <pre><code>conda install pywavelets\n</code></pre> <p>Several Linux distributions have their own packages for PyWavelets, but these tend to be moderately out of date.  Query your Linux package manager tool for <code>python-pywavelets</code>, <code>python-wavelets</code>, <code>python-pywt</code> or a similar package name.</p>"},{"location":"install/#building-from-source","title":"Building from source","text":"<p>The most recent development version can be found on GitHub at https://github.com/PyWavelets/pywt.</p> <p>If you want or need to install from source, you will need a working C compiler (any common one will work) installed on your system.  Navigate to the PyWavelets source code directory (containing <code>pyproject.toml.py</code>) and type::</p> <pre><code>pip install .\n</code></pre> <p>For the requirements needed to build from source are (Python, NumPy and Cython minimum versions in particular), see <code>pyproject.toml</code>.</p> <p>To run all the tests for PyWavelets, you will also need to install the Matplotlib_ package. If SciPy_ is available, FFT-based continuous wavelet transforms will use the FFT implementation from SciPy instead of NumPy.</p> <p>Seealso</p> <p>The Development guide section contains more information on building and installing from source code.</p>"},{"location":"dev/","title":"Development guide","text":"<p>This section contains information on building and installing PyWavelets from source code as well as instructions for preparing the build environment on Windows and Linux.</p>"},{"location":"dev/#something-not-working","title":"Something not working?","text":"<p>If these instructions are not clear or you need help setting up your development environment, go ahead and ask on the PyWavelets discussion group at http://groups.google.com/group/pywavelets or open a ticket on GitHub.</p>"},{"location":"ref/","title":"API Reference","text":"<p>Discrete forward and inverse wavelet transform, stationary wavelet transform, wavelet packets signal decomposition and reconstruction module.</p>"},{"location":"ref/#pywt.BaseNode","title":"<code>BaseNode</code>","text":"<p>BaseNode for wavelet packet 1D and 2D tree nodes.</p> <p>The BaseNode is a base class for <code>Node</code> and <code>Node2D</code>. It should not be used directly unless creating a new transformation type. It is included here to document the common interface of 1D and 2D node and wavelet packet transform classes.</p>"},{"location":"ref/#pywt.BaseNode--parameters","title":"Parameters","text":"<p>parent :     Parent node. If parent is None then the node is considered detached     (ie root). data : 1D or 2D array     Data associated with the node. 1D or 2D numeric array, depending on the     transform type. node_name :     A name identifying the coefficients type.     See <code>Node.node_name</code> and <code>Node2D.node_name</code>     for information on the accepted subnodes names.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class BaseNode:\n    \"\"\"\n    BaseNode for wavelet packet 1D and 2D tree nodes.\n\n    The BaseNode is a base class for `Node` and `Node2D`.\n    It should not be used directly unless creating a new transformation\n    type. It is included here to document the common interface of 1D\n    and 2D node and wavelet packet transform classes.\n\n    Parameters\n    ----------\n    parent :\n        Parent node. If parent is None then the node is considered detached\n        (ie root).\n    data : 1D or 2D array\n        Data associated with the node. 1D or 2D numeric array, depending on the\n        transform type.\n    node_name :\n        A name identifying the coefficients type.\n        See `Node.node_name` and `Node2D.node_name`\n        for information on the accepted subnodes names.\n    \"\"\"\n\n    # PART_LEN and PARTS attributes that define path tokens for node[] lookup\n    # must be defined in subclasses.\n    PART_LEN = None\n    PARTS = None\n\n    def __init__(self, parent, data, node_name):\n        self.parent = parent\n        if parent is not None:\n            self.wavelet = parent.wavelet\n            self.mode = parent.mode\n            self.level = parent.level + 1\n            self._maxlevel = parent.maxlevel\n            self.path = parent.path + node_name\n            self.axes = parent.axes\n        else:\n            self.wavelet = None\n            self.mode = None\n            self.axes = None\n            self.path = \"\"\n            self.level = 0\n\n        # data - signal on level 0, coeffs on higher levels\n        self.data = data\n        # Need to retain original data size/shape so we can trim any excess\n        # boundary coefficients from the inverse transform.\n        if self.data is None:\n            self._data_shape = None\n        else:\n            self._data_shape = np.asarray(data).shape\n\n        self._init_subnodes()\n\n    def _init_subnodes(self):\n        for part in self.PARTS:\n            self._set_node(part, None)\n\n    def _create_subnode(self, part, data=None, overwrite=True):\n        raise NotImplementedError()\n\n    def _create_subnode_base(self, node_cls, part, data=None, overwrite=True,\n                             **kwargs):\n        self._validate_node_name(part)\n        if not overwrite and self._get_node(part) is not None:\n            return self._get_node(part)\n        node = node_cls(self, data, part, **kwargs)\n        self._set_node(part, node)\n        return node\n\n    def _get_node(self, part):\n        return getattr(self, part)\n\n    def _set_node(self, part, node):\n        setattr(self, part, node)\n\n    def _delete_node(self, part):\n        self._set_node(part, None)\n\n    def _validate_node_name(self, part):\n        if part not in self.PARTS:\n            raise ValueError(\"Subnode name must be in [{}], not '{}'.\".format(', '.join(\"'%s'\" % p for p in self.PARTS), part))\n\n    @property\n    def path_tuple(self):\n        \"\"\"The path to the current node in tuple form.\n\n        The length of the tuple is equal to the number of decomposition levels.\n        \"\"\"\n        path = self.path\n        nlev = len(path)//self.PART_LEN\n        return tuple([path[(n-1)*self.PART_LEN:n*self.PART_LEN]\n                      for n in range(1, nlev+1)])\n\n    def _evaluate_maxlevel(self, evaluate_from='parent'):\n        \"\"\"\n        Try to find the value of maximum decomposition level if it is not\n        specified explicitly.\n\n        Parameters\n        ----------\n        evaluate_from : {'parent', 'subnodes'}\n        \"\"\"\n        assert evaluate_from in ('parent', 'subnodes')\n\n        if self._maxlevel is not None:\n            return self._maxlevel\n        elif self.data is not None:\n            return self.level + dwt_max_level(\n                min(self.data.shape), self.wavelet)\n\n        if evaluate_from == 'parent':\n            if self.parent is not None:\n                return self.parent._evaluate_maxlevel(evaluate_from)\n        elif evaluate_from == 'subnodes':\n            for node_name in self.PARTS:\n                node = getattr(self, node_name, None)\n                if node is not None:\n                    level = node._evaluate_maxlevel(evaluate_from)\n                    if level is not None:\n                        return level\n        return None\n\n    @property\n    def maxlevel(self):\n        if self._maxlevel is not None:\n            return self._maxlevel\n\n        # Try getting the maxlevel from parents first\n        self._maxlevel = self._evaluate_maxlevel(evaluate_from='parent')\n\n        # If not found, check whether it can be evaluated from subnodes\n        if self._maxlevel is None:\n            self._maxlevel = self._evaluate_maxlevel(evaluate_from='subnodes')\n        return self._maxlevel\n\n    @property\n    def node_name(self):\n        return self.path[-self.PART_LEN:]\n\n    def decompose(self):\n        \"\"\"\n        Decompose node data creating DWT coefficients subnodes.\n\n        Performs Discrete Wavelet Transform on the `~BaseNode.data` and\n        returns transform coefficients.\n\n        Note\n        ----\n        Descends to subnodes and recursively\n        calls `~BaseNode.reconstruct` on them.\n\n        \"\"\"\n        if self.level &lt; self.maxlevel:\n            return self._decompose()\n        else:\n            raise ValueError(\"Maximum decomposition level reached.\")\n\n    def _decompose(self):\n        raise NotImplementedError()\n\n    def reconstruct(self, update=False):\n        \"\"\"\n        Reconstruct node from subnodes.\n\n        Parameters\n        ----------\n        update : bool, optional\n            If True, then reconstructed data replaces the current\n            node data (default: False).\n\n        Returns:\n            - original node data if subnodes do not exist\n            - IDWT of subnodes otherwise.\n        \"\"\"\n        if not self.has_any_subnode:\n            return self.data\n        return self._reconstruct(update)\n\n    def _reconstruct(self):\n        raise NotImplementedError()  # override this in subclasses\n\n    def get_subnode(self, part, decompose=True):\n        \"\"\"\n        Returns subnode or None (see `decomposition` flag description).\n\n        Parameters\n        ----------\n        part :\n            Subnode name\n        decompose : bool, optional\n            If the param is True and corresponding subnode does not\n            exist, the subnode will be created using coefficients\n            from the DWT decomposition of the current node.\n            (default: True)\n        \"\"\"\n        self._validate_node_name(part)\n        subnode = self._get_node(part)\n        if subnode is None and decompose and not self.is_empty:\n            self.decompose()\n            subnode = self._get_node(part)\n        return subnode\n\n    def __getitem__(self, path):\n        \"\"\"\n        Find node represented by the given path.\n\n        Similar to `~BaseNode.get_subnode` method with `decompose=True`, but\n        can access nodes on any level in the decomposition tree.\n\n        Parameters\n        ----------\n        path : str\n            String composed of node names. See `Node.node_name` and\n            `Node2D.node_name` for node naming convention.\n\n        Notes\n        -----\n        If node does not exist yet, it will be created by decomposition of its\n        parent node.\n        \"\"\"\n        errmsg = (\"Invalid path parameter type - expected string or \"\n                  \"tuple of strings but got %s.\" % type(path))\n        if isinstance(path, tuple):\n            # concatenate tuple of strings into a single string\n            try:\n                path = ''.join(path)\n            except TypeError:\n                raise TypeError(errmsg)\n        if isinstance(path, str):\n            if (self.maxlevel is not None and\n                    len(path) &gt; self.maxlevel * self.PART_LEN):\n                raise IndexError(\"Path length is out of range.\")\n            if path:\n                return self.get_subnode(path[0:self.PART_LEN], True)[\n                    path[self.PART_LEN:]]\n            else:\n                return self\n        else:\n            raise TypeError(errmsg)\n\n    def __setitem__(self, path, data):\n        \"\"\"\n        Set node or node's data in the decomposition tree. Nodes are\n        identified by string `path`.\n\n        Parameters\n        ----------\n        path : str\n            String composed of node names.\n        data : array or BaseNode subclass.\n        \"\"\"\n\n        if isinstance(path, str):\n            if (\n                self.maxlevel is not None and\n                len(self.path) + len(path) &gt; self.maxlevel * self.PART_LEN\n            ):\n                raise IndexError(\"Path length out of range.\")\n            if path:\n                subnode = self.get_subnode(path[0:self.PART_LEN], False)\n                if subnode is None:\n                    self._create_subnode(path[0:self.PART_LEN], None)\n                    subnode = self.get_subnode(path[0:self.PART_LEN], False)\n                subnode[path[self.PART_LEN:]] = data\n            else:\n                if isinstance(data, BaseNode):\n                    self.data = np.asarray(data.data)\n                else:\n                    self.data = np.asarray(data)\n                # convert data to nearest supported dtype\n                dtype = _check_dtype(data)\n                if self.data.dtype != dtype:\n                    self.data = self.data.astype(dtype)\n        else:\n            raise TypeError(\"Invalid path parameter type - expected string but\"\n                            \" got %s.\" % type(path))\n\n    def __delitem__(self, path):\n        \"\"\"\n        Remove node from the tree.\n\n        Parameters\n        ----------\n        path : str\n            String composed of node names.\n        \"\"\"\n        node = self[path]\n        # don't clear node value and subnodes (node may still exist outside\n        # the tree)\n        # # node._init_subnodes()\n        # # node.data = None\n        parent = node.parent\n        node.parent = None  # TODO\n        if parent and node.node_name:\n            parent._delete_node(node.node_name)\n\n    @property\n    def is_empty(self):\n        return self.data is None\n\n    @property\n    def has_any_subnode(self):\n        return any(self._get_node(part) is not None for part in self.PARTS)\n\n    def get_leaf_nodes(self, decompose=False):\n        \"\"\"\n        Returns leaf nodes.\n\n        Parameters\n        ----------\n        decompose : bool, optional\n            (default: True)\n        \"\"\"\n        result = []\n\n        def collect(node):\n            if node.level == node.maxlevel and not node.is_empty:\n                result.append(node)\n                return False\n            if not decompose and not node.has_any_subnode:\n                result.append(node)\n                return False\n            return True\n        self.walk(collect, decompose=decompose)\n        return result\n\n    def walk(self, func, args=(), kwargs=None, decompose=True):\n        \"\"\"\n        Traverses the decomposition tree and calls\n        ``func(node, *args, **kwargs)`` on every node. If `func` returns True,\n        descending to subnodes will continue.\n\n        Parameters\n        ----------\n        func : callable\n            Callable accepting `BaseNode` as the first param and\n            optional positional and keyword arguments\n        args :\n            func params\n        kwargs :\n            func keyword params\n        decompose : bool, optional\n            If True (default), the method will also try to decompose the tree\n            up to the `maximum level &lt;BaseNode.maxlevel&gt;`.\n        \"\"\"\n        if kwargs is None:\n            kwargs = {}\n        if func(self, *args, **kwargs) and self.level &lt; self.maxlevel:\n            for part in self.PARTS:\n                subnode = self.get_subnode(part, decompose)\n                if subnode is not None:\n                    subnode.walk(func, args, kwargs, decompose)\n\n    def walk_depth(self, func, args=(), kwargs=None, decompose=True):\n        \"\"\"\n        Walk tree and call func on every node starting from the bottom-most\n        nodes.\n\n        Parameters\n        ----------\n        func : callable\n            Callable accepting :class:`BaseNode` as the first param and\n            optional positional and keyword arguments\n        args :\n            func params\n        kwargs :\n            func keyword params\n        decompose : bool, optional\n            (default: False)\n        \"\"\"\n        if kwargs is None:\n            kwargs = {}\n        if self.level &lt; self.maxlevel:\n            for part in self.PARTS:\n                subnode = self.get_subnode(part, decompose)\n                if subnode is not None:\n                    subnode.walk_depth(func, args, kwargs, decompose)\n        func(self, *args, **kwargs)\n\n    def __str__(self):\n        return self.path + \": \" + str(self.data)\n</code></pre>"},{"location":"ref/#pywt.BaseNode.path_tuple","title":"<code>path_tuple</code>  <code>property</code>","text":"<p>The path to the current node in tuple form.</p> <p>The length of the tuple is equal to the number of decomposition levels.</p>"},{"location":"ref/#pywt.BaseNode.__delitem__","title":"<code>__delitem__(path)</code>","text":"<p>Remove node from the tree.</p>"},{"location":"ref/#pywt.BaseNode.__delitem__--parameters","title":"Parameters","text":"<p>path : str     String composed of node names.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def __delitem__(self, path):\n    \"\"\"\n    Remove node from the tree.\n\n    Parameters\n    ----------\n    path : str\n        String composed of node names.\n    \"\"\"\n    node = self[path]\n    # don't clear node value and subnodes (node may still exist outside\n    # the tree)\n    # # node._init_subnodes()\n    # # node.data = None\n    parent = node.parent\n    node.parent = None  # TODO\n    if parent and node.node_name:\n        parent._delete_node(node.node_name)\n</code></pre>"},{"location":"ref/#pywt.BaseNode.__getitem__","title":"<code>__getitem__(path)</code>","text":"<p>Find node represented by the given path.</p> <p>Similar to <code>~BaseNode.get_subnode</code> method with <code>decompose=True</code>, but can access nodes on any level in the decomposition tree.</p>"},{"location":"ref/#pywt.BaseNode.__getitem__--parameters","title":"Parameters","text":"<p>path : str     String composed of node names. See <code>Node.node_name</code> and     <code>Node2D.node_name</code> for node naming convention.</p>"},{"location":"ref/#pywt.BaseNode.__getitem__--notes","title":"Notes","text":"<p>If node does not exist yet, it will be created by decomposition of its parent node.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def __getitem__(self, path):\n    \"\"\"\n    Find node represented by the given path.\n\n    Similar to `~BaseNode.get_subnode` method with `decompose=True`, but\n    can access nodes on any level in the decomposition tree.\n\n    Parameters\n    ----------\n    path : str\n        String composed of node names. See `Node.node_name` and\n        `Node2D.node_name` for node naming convention.\n\n    Notes\n    -----\n    If node does not exist yet, it will be created by decomposition of its\n    parent node.\n    \"\"\"\n    errmsg = (\"Invalid path parameter type - expected string or \"\n              \"tuple of strings but got %s.\" % type(path))\n    if isinstance(path, tuple):\n        # concatenate tuple of strings into a single string\n        try:\n            path = ''.join(path)\n        except TypeError:\n            raise TypeError(errmsg)\n    if isinstance(path, str):\n        if (self.maxlevel is not None and\n                len(path) &gt; self.maxlevel * self.PART_LEN):\n            raise IndexError(\"Path length is out of range.\")\n        if path:\n            return self.get_subnode(path[0:self.PART_LEN], True)[\n                path[self.PART_LEN:]]\n        else:\n            return self\n    else:\n        raise TypeError(errmsg)\n</code></pre>"},{"location":"ref/#pywt.BaseNode.__setitem__","title":"<code>__setitem__(path, data)</code>","text":"<p>Set node or node's data in the decomposition tree. Nodes are identified by string <code>path</code>.</p>"},{"location":"ref/#pywt.BaseNode.__setitem__--parameters","title":"Parameters","text":"<p>path : str     String composed of node names. data : array or BaseNode subclass.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def __setitem__(self, path, data):\n    \"\"\"\n    Set node or node's data in the decomposition tree. Nodes are\n    identified by string `path`.\n\n    Parameters\n    ----------\n    path : str\n        String composed of node names.\n    data : array or BaseNode subclass.\n    \"\"\"\n\n    if isinstance(path, str):\n        if (\n            self.maxlevel is not None and\n            len(self.path) + len(path) &gt; self.maxlevel * self.PART_LEN\n        ):\n            raise IndexError(\"Path length out of range.\")\n        if path:\n            subnode = self.get_subnode(path[0:self.PART_LEN], False)\n            if subnode is None:\n                self._create_subnode(path[0:self.PART_LEN], None)\n                subnode = self.get_subnode(path[0:self.PART_LEN], False)\n            subnode[path[self.PART_LEN:]] = data\n        else:\n            if isinstance(data, BaseNode):\n                self.data = np.asarray(data.data)\n            else:\n                self.data = np.asarray(data)\n            # convert data to nearest supported dtype\n            dtype = _check_dtype(data)\n            if self.data.dtype != dtype:\n                self.data = self.data.astype(dtype)\n    else:\n        raise TypeError(\"Invalid path parameter type - expected string but\"\n                        \" got %s.\" % type(path))\n</code></pre>"},{"location":"ref/#pywt.BaseNode.decompose","title":"<code>decompose()</code>","text":"<p>Decompose node data creating DWT coefficients subnodes.</p> <p>Performs Discrete Wavelet Transform on the <code>~BaseNode.data</code> and returns transform coefficients.</p>"},{"location":"ref/#pywt.BaseNode.decompose--note","title":"Note","text":"<p>Descends to subnodes and recursively calls <code>~BaseNode.reconstruct</code> on them.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def decompose(self):\n    \"\"\"\n    Decompose node data creating DWT coefficients subnodes.\n\n    Performs Discrete Wavelet Transform on the `~BaseNode.data` and\n    returns transform coefficients.\n\n    Note\n    ----\n    Descends to subnodes and recursively\n    calls `~BaseNode.reconstruct` on them.\n\n    \"\"\"\n    if self.level &lt; self.maxlevel:\n        return self._decompose()\n    else:\n        raise ValueError(\"Maximum decomposition level reached.\")\n</code></pre>"},{"location":"ref/#pywt.BaseNode.get_leaf_nodes","title":"<code>get_leaf_nodes(decompose=False)</code>","text":"<p>Returns leaf nodes.</p>"},{"location":"ref/#pywt.BaseNode.get_leaf_nodes--parameters","title":"Parameters","text":"<p>decompose : bool, optional     (default: True)</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def get_leaf_nodes(self, decompose=False):\n    \"\"\"\n    Returns leaf nodes.\n\n    Parameters\n    ----------\n    decompose : bool, optional\n        (default: True)\n    \"\"\"\n    result = []\n\n    def collect(node):\n        if node.level == node.maxlevel and not node.is_empty:\n            result.append(node)\n            return False\n        if not decompose and not node.has_any_subnode:\n            result.append(node)\n            return False\n        return True\n    self.walk(collect, decompose=decompose)\n    return result\n</code></pre>"},{"location":"ref/#pywt.BaseNode.get_subnode","title":"<code>get_subnode(part, decompose=True)</code>","text":"<p>Returns subnode or None (see <code>decomposition</code> flag description).</p>"},{"location":"ref/#pywt.BaseNode.get_subnode--parameters","title":"Parameters","text":"<p>part :     Subnode name decompose : bool, optional     If the param is True and corresponding subnode does not     exist, the subnode will be created using coefficients     from the DWT decomposition of the current node.     (default: True)</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def get_subnode(self, part, decompose=True):\n    \"\"\"\n    Returns subnode or None (see `decomposition` flag description).\n\n    Parameters\n    ----------\n    part :\n        Subnode name\n    decompose : bool, optional\n        If the param is True and corresponding subnode does not\n        exist, the subnode will be created using coefficients\n        from the DWT decomposition of the current node.\n        (default: True)\n    \"\"\"\n    self._validate_node_name(part)\n    subnode = self._get_node(part)\n    if subnode is None and decompose and not self.is_empty:\n        self.decompose()\n        subnode = self._get_node(part)\n    return subnode\n</code></pre>"},{"location":"ref/#pywt.BaseNode.reconstruct","title":"<code>reconstruct(update=False)</code>","text":"<p>Reconstruct node from subnodes.</p>"},{"location":"ref/#pywt.BaseNode.reconstruct--parameters","title":"Parameters","text":"<p>update : bool, optional     If True, then reconstructed data replaces the current     node data (default: False).</p> <p>Returns:</p> Type Description <ul> <li>original node data if subnodes do not exist</li> </ul> <ul> <li>IDWT of subnodes otherwise.</li> </ul> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def reconstruct(self, update=False):\n    \"\"\"\n    Reconstruct node from subnodes.\n\n    Parameters\n    ----------\n    update : bool, optional\n        If True, then reconstructed data replaces the current\n        node data (default: False).\n\n    Returns:\n        - original node data if subnodes do not exist\n        - IDWT of subnodes otherwise.\n    \"\"\"\n    if not self.has_any_subnode:\n        return self.data\n    return self._reconstruct(update)\n</code></pre>"},{"location":"ref/#pywt.BaseNode.walk","title":"<code>walk(func, args=(), kwargs=None, decompose=True)</code>","text":"<p>Traverses the decomposition tree and calls <code>func(node, *args, **kwargs)</code> on every node. If <code>func</code> returns True, descending to subnodes will continue.</p>"},{"location":"ref/#pywt.BaseNode.walk--parameters","title":"Parameters","text":"<p>func : callable     Callable accepting <code>BaseNode</code> as the first param and     optional positional and keyword arguments args :     func params kwargs :     func keyword params decompose : bool, optional     If True (default), the method will also try to decompose the tree     up to the <code>maximum level &lt;BaseNode.maxlevel&gt;</code>.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def walk(self, func, args=(), kwargs=None, decompose=True):\n    \"\"\"\n    Traverses the decomposition tree and calls\n    ``func(node, *args, **kwargs)`` on every node. If `func` returns True,\n    descending to subnodes will continue.\n\n    Parameters\n    ----------\n    func : callable\n        Callable accepting `BaseNode` as the first param and\n        optional positional and keyword arguments\n    args :\n        func params\n    kwargs :\n        func keyword params\n    decompose : bool, optional\n        If True (default), the method will also try to decompose the tree\n        up to the `maximum level &lt;BaseNode.maxlevel&gt;`.\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n    if func(self, *args, **kwargs) and self.level &lt; self.maxlevel:\n        for part in self.PARTS:\n            subnode = self.get_subnode(part, decompose)\n            if subnode is not None:\n                subnode.walk(func, args, kwargs, decompose)\n</code></pre>"},{"location":"ref/#pywt.BaseNode.walk_depth","title":"<code>walk_depth(func, args=(), kwargs=None, decompose=True)</code>","text":"<p>Walk tree and call func on every node starting from the bottom-most nodes.</p>"},{"location":"ref/#pywt.BaseNode.walk_depth--parameters","title":"Parameters","text":"<p>func : callable     Callable accepting :class:<code>BaseNode</code> as the first param and     optional positional and keyword arguments args :     func params kwargs :     func keyword params decompose : bool, optional     (default: False)</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def walk_depth(self, func, args=(), kwargs=None, decompose=True):\n    \"\"\"\n    Walk tree and call func on every node starting from the bottom-most\n    nodes.\n\n    Parameters\n    ----------\n    func : callable\n        Callable accepting :class:`BaseNode` as the first param and\n        optional positional and keyword arguments\n    args :\n        func params\n    kwargs :\n        func keyword params\n    decompose : bool, optional\n        (default: False)\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n    if self.level &lt; self.maxlevel:\n        for part in self.PARTS:\n            subnode = self.get_subnode(part, decompose)\n            if subnode is not None:\n                subnode.walk_depth(func, args, kwargs, decompose)\n    func(self, *args, **kwargs)\n</code></pre>"},{"location":"ref/#pywt.FswavedecnResult","title":"<code>FswavedecnResult</code>","text":"<p>Object representing fully separable wavelet transform coefficients.</p>"},{"location":"ref/#pywt.FswavedecnResult--parameters","title":"Parameters","text":"<p>coeffs : ndarray     The coefficient array. coeff_slices : list     List of slices corresponding to each detail or approximation     coefficient array. wavelets : list of pywt.DiscreteWavelet objects     The wavelets used.  Will be a list with length equal to     <code>len(axes)</code>. mode_enums : list of int     The border modes used.  Will be a list with length equal to     <code>len(axes)</code>. axes : tuple of int     The set of axes over which the transform was performed.</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>class FswavedecnResult:\n    \"\"\"Object representing fully separable wavelet transform coefficients.\n\n    Parameters\n    ----------\n    coeffs : ndarray\n        The coefficient array.\n    coeff_slices : list\n        List of slices corresponding to each detail or approximation\n        coefficient array.\n    wavelets : list of pywt.DiscreteWavelet objects\n        The wavelets used.  Will be a list with length equal to\n        ``len(axes)``.\n    mode_enums : list of int\n        The border modes used.  Will be a list with length equal to\n        ``len(axes)``.\n    axes : tuple of int\n        The set of axes over which the transform was performed.\n\n    \"\"\"\n    def __init__(self, coeffs, coeff_slices, wavelets, mode_enums,\n                 axes):\n        self._coeffs = coeffs\n        self._coeff_slices = coeff_slices\n        self._axes = axes\n        if not np.all(isinstance(w, Wavelet) for w in wavelets):\n            raise ValueError(\n                \"wavelets must contain pywt.Wavelet objects\")\n        self._wavelets = wavelets\n        if not np.all(isinstance(m, int) for m in mode_enums):\n            raise ValueError(\n                \"mode_enums must be integers\")\n        self._mode_enums = mode_enums\n\n    @property\n    def coeffs(self):\n        \"\"\"ndarray: All coefficients stacked into a single array.\"\"\"\n        return self._coeffs\n\n    @coeffs.setter\n    def coeffs(self, c):\n        if c.shape != self._coeffs.shape:\n            raise ValueError(\"new coefficient array must match the existing \"\n                             \"coefficient shape\")\n        self._coeffs = c\n\n    @property\n    def coeff_slices(self):\n        \"\"\"List: List of coefficient slices.\"\"\"\n        return self._coeff_slices\n\n    @property\n    def ndim(self):\n        \"\"\"int: Number of data dimensions.\"\"\"\n        return self.coeffs.ndim\n\n    @property\n    def ndim_transform(self):\n        \"\"\"int: Number of axes transformed.\"\"\"\n        return len(self.axes)\n\n    @property\n    def axes(self):\n        \"\"\"List of str: The axes the transform was performed along.\"\"\"\n        return self._axes\n\n    @property\n    def levels(self):\n        \"\"\"List of int: Levels of decomposition along each transformed axis.\"\"\"\n        return [len(s) - 1 for s in self.coeff_slices]\n\n    @property\n    def wavelets(self):\n        \"\"\"List of pywt.DiscreteWavelet: wavelet for each transformed axis.\"\"\"\n        return self._wavelets\n\n    @property\n    def wavelet_names(self):\n        \"\"\"List of pywt.DiscreteWavelet: wavelet for each transformed axis.\"\"\"\n        return [w.name for w in self._wavelets]\n\n    @property\n    def modes(self):\n        \"\"\"List of str: The border mode used along each transformed axis.\"\"\"\n        names_dict = {getattr(Modes, mode): mode\n                      for mode in Modes.modes}\n        return [names_dict[m] for m in self._mode_enums]\n\n    def _get_coef_sl(self, levels):\n        sl = [slice(None), ] * self.ndim\n        for n, (ax, lev) in enumerate(zip(self.axes, levels)):\n            sl[ax] = self.coeff_slices[n][lev]\n        return tuple(sl)\n\n    @property\n    def approx(self):\n        \"\"\"ndarray: The approximation coefficients.\"\"\"\n        sl = self._get_coef_sl((0, )*self.ndim)\n        return self._coeffs[sl]\n\n    @approx.setter\n    def approx(self, a):\n        sl = self._get_coef_sl((0, )*self.ndim)\n        if self._coeffs[sl].shape != a.shape:\n            raise ValueError(\n                \"x does not match the shape of the requested coefficient\")\n        self._coeffs[sl] = a\n\n    def _validate_index(self, levels):\n        levels = tuple(levels)\n\n        if len(levels) != len(self.axes):\n            raise ValueError(\n                \"levels must match the number of transformed axes\")\n\n        # check that all elements are non-negative integers\n        if (not np.all([isinstance(lev, numbers.Number) for lev in levels]) or\n                np.any(np.asarray(levels) % 1 &gt; 0) or\n                np.any([lev &lt; 0 for lev in levels])):\n            raise ValueError(\"Index must be a tuple of non-negative integers\")\n        # convert integer-valued floats to int\n        levels = tuple([int(lev) for lev in levels])\n\n        # check for out of range levels\n        if np.any([lev &gt; maxlev for lev, maxlev in zip(levels, self.levels)]):\n            raise ValueError(\n                \"Specified indices exceed the number of transform levels.\")\n\n    def __getitem__(self, levels):\n        \"\"\"Retrieve a coefficient subband.\n\n        Parameters\n        ----------\n        levels : tuple of int\n            The number of degrees of decomposition along each transformed\n            axis.\n        \"\"\"\n        self._validate_index(levels)\n        sl = self._get_coef_sl(levels)\n        return self._coeffs[sl]\n\n    def __setitem__(self, levels, x):\n        \"\"\"Assign values to a coefficient subband.\n\n        Parameters\n        ----------\n        levels : tuple of int\n            The number of degrees of decomposition along each transformed\n            axis.\n        x : ndarray\n            The data corresponding to assign. It must match the expected\n            shape and dtype of the specified subband.\n        \"\"\"\n        self._validate_index(levels)\n        sl = self._get_coef_sl(levels)\n        current_dtype = self._coeffs[sl].dtype\n        if self._coeffs[sl].shape != x.shape:\n            raise ValueError(\n                \"x does not match the shape of the requested coefficient\")\n        if x.dtype != current_dtype:\n            warnings.warn(\"dtype mismatch:  converting the provided array to\"\n                          f\"dtype {current_dtype}\")\n        self._coeffs[sl] = x\n\n    def detail_keys(self):\n        \"\"\"Return a list of all detail coefficient keys.\n\n        Returns\n        -------\n        keys : list of str\n            List of all detail coefficient keys.\n        \"\"\"\n        keys = list(product(*(range(l+1) for l in self.levels)))\n        keys.remove((0, )*len(self.axes))\n        return sorted(keys)\n</code></pre>"},{"location":"ref/#pywt.FswavedecnResult.approx","title":"<code>approx</code>  <code>property</code> <code>writable</code>","text":"<p>ndarray: The approximation coefficients.</p>"},{"location":"ref/#pywt.FswavedecnResult.axes","title":"<code>axes</code>  <code>property</code>","text":"<p>List of str: The axes the transform was performed along.</p>"},{"location":"ref/#pywt.FswavedecnResult.coeff_slices","title":"<code>coeff_slices</code>  <code>property</code>","text":"<p>List: List of coefficient slices.</p>"},{"location":"ref/#pywt.FswavedecnResult.coeffs","title":"<code>coeffs</code>  <code>property</code> <code>writable</code>","text":"<p>ndarray: All coefficients stacked into a single array.</p>"},{"location":"ref/#pywt.FswavedecnResult.levels","title":"<code>levels</code>  <code>property</code>","text":"<p>List of int: Levels of decomposition along each transformed axis.</p>"},{"location":"ref/#pywt.FswavedecnResult.modes","title":"<code>modes</code>  <code>property</code>","text":"<p>List of str: The border mode used along each transformed axis.</p>"},{"location":"ref/#pywt.FswavedecnResult.ndim","title":"<code>ndim</code>  <code>property</code>","text":"<p>int: Number of data dimensions.</p>"},{"location":"ref/#pywt.FswavedecnResult.ndim_transform","title":"<code>ndim_transform</code>  <code>property</code>","text":"<p>int: Number of axes transformed.</p>"},{"location":"ref/#pywt.FswavedecnResult.wavelet_names","title":"<code>wavelet_names</code>  <code>property</code>","text":"<p>List of pywt.DiscreteWavelet: wavelet for each transformed axis.</p>"},{"location":"ref/#pywt.FswavedecnResult.wavelets","title":"<code>wavelets</code>  <code>property</code>","text":"<p>List of pywt.DiscreteWavelet: wavelet for each transformed axis.</p>"},{"location":"ref/#pywt.FswavedecnResult.__getitem__","title":"<code>__getitem__(levels)</code>","text":"<p>Retrieve a coefficient subband.</p>"},{"location":"ref/#pywt.FswavedecnResult.__getitem__--parameters","title":"Parameters","text":"<p>levels : tuple of int     The number of degrees of decomposition along each transformed     axis.</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def __getitem__(self, levels):\n    \"\"\"Retrieve a coefficient subband.\n\n    Parameters\n    ----------\n    levels : tuple of int\n        The number of degrees of decomposition along each transformed\n        axis.\n    \"\"\"\n    self._validate_index(levels)\n    sl = self._get_coef_sl(levels)\n    return self._coeffs[sl]\n</code></pre>"},{"location":"ref/#pywt.FswavedecnResult.__setitem__","title":"<code>__setitem__(levels, x)</code>","text":"<p>Assign values to a coefficient subband.</p>"},{"location":"ref/#pywt.FswavedecnResult.__setitem__--parameters","title":"Parameters","text":"<p>levels : tuple of int     The number of degrees of decomposition along each transformed     axis. x : ndarray     The data corresponding to assign. It must match the expected     shape and dtype of the specified subband.</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def __setitem__(self, levels, x):\n    \"\"\"Assign values to a coefficient subband.\n\n    Parameters\n    ----------\n    levels : tuple of int\n        The number of degrees of decomposition along each transformed\n        axis.\n    x : ndarray\n        The data corresponding to assign. It must match the expected\n        shape and dtype of the specified subband.\n    \"\"\"\n    self._validate_index(levels)\n    sl = self._get_coef_sl(levels)\n    current_dtype = self._coeffs[sl].dtype\n    if self._coeffs[sl].shape != x.shape:\n        raise ValueError(\n            \"x does not match the shape of the requested coefficient\")\n    if x.dtype != current_dtype:\n        warnings.warn(\"dtype mismatch:  converting the provided array to\"\n                      f\"dtype {current_dtype}\")\n    self._coeffs[sl] = x\n</code></pre>"},{"location":"ref/#pywt.FswavedecnResult.detail_keys","title":"<code>detail_keys()</code>","text":"<p>Return a list of all detail coefficient keys.</p>"},{"location":"ref/#pywt.FswavedecnResult.detail_keys--returns","title":"Returns","text":"<p>keys : list of str     List of all detail coefficient keys.</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def detail_keys(self):\n    \"\"\"Return a list of all detail coefficient keys.\n\n    Returns\n    -------\n    keys : list of str\n        List of all detail coefficient keys.\n    \"\"\"\n    keys = list(product(*(range(l+1) for l in self.levels)))\n    keys.remove((0, )*len(self.axes))\n    return sorted(keys)\n</code></pre>"},{"location":"ref/#pywt.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>BaseNode</code></p> <p>WaveletPacket tree node.</p> <p>Subnodes are called <code>a</code> and <code>d</code>, just like approximation and detail coefficients in the Discrete Wavelet Transform.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class Node(BaseNode):\n    \"\"\"\n    WaveletPacket tree node.\n\n    Subnodes are called `a` and `d`, just like approximation\n    and detail coefficients in the Discrete Wavelet Transform.\n    \"\"\"\n\n    A = 'a'\n    D = 'd'\n    PARTS = A, D\n    PART_LEN = 1\n\n    def _create_subnode(self, part, data=None, overwrite=True):\n        return self._create_subnode_base(node_cls=Node, part=part, data=data,\n                                         overwrite=overwrite)\n\n    def _decompose(self):\n        \"\"\"\n\n        See also\n        --------\n        dwt : for 1D Discrete Wavelet Transform output coefficients.\n        \"\"\"\n        if self.is_empty:\n            data_a, data_d = None, None\n            if self._get_node(self.A) is None:\n                self._create_subnode(self.A, data_a)\n            if self._get_node(self.D) is None:\n                self._create_subnode(self.D, data_d)\n        else:\n            data_a, data_d = dwt(self.data, self.wavelet, self.mode,\n                                 axis=self.axes)\n            self._create_subnode(self.A, data_a)\n            self._create_subnode(self.D, data_d)\n        return self._get_node(self.A), self._get_node(self.D)\n\n    def _reconstruct(self, update):\n        data_a, data_d = None, None\n        node_a, node_d = self._get_node(self.A), self._get_node(self.D)\n\n        if node_a is not None:\n            data_a = node_a.reconstruct()  # TODO: (update) ???\n        if node_d is not None:\n            data_d = node_d.reconstruct()  # TODO: (update) ???\n\n        if data_a is None and data_d is None:\n            raise ValueError(\"Node is a leaf node and cannot be reconstructed\"\n                             \" from subnodes.\")\n        else:\n            rec = idwt(data_a, data_d, self.wavelet, self.mode, axis=self.axes)\n            if self._data_shape is not None and (\n                    rec.shape != self._data_shape):\n                rec = rec[tuple([slice(sz) for sz in self._data_shape])]\n            if update:\n                self.data = rec\n            return rec\n</code></pre>"},{"location":"ref/#pywt.Node2D","title":"<code>Node2D</code>","text":"<p>               Bases: <code>BaseNode</code></p> <p>WaveletPacket tree node.</p> <p>Subnodes are called 'a' (LL), 'h' (HL), 'v' (LH) and  'd' (HH), like approximation and detail coefficients in the 2D Discrete Wavelet Transform</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class Node2D(BaseNode):\n    \"\"\"\n    WaveletPacket tree node.\n\n    Subnodes are called 'a' (LL), 'h' (HL), 'v' (LH) and  'd' (HH), like\n    approximation and detail coefficients in the 2D Discrete Wavelet Transform\n    \"\"\"\n\n    LL = 'a'\n    HL = 'h'\n    LH = 'v'\n    HH = 'd'\n\n    PARTS = LL, HL, LH, HH\n    PART_LEN = 1\n\n    def _create_subnode(self, part, data=None, overwrite=True):\n        return self._create_subnode_base(node_cls=Node2D, part=part, data=data,\n                                         overwrite=overwrite)\n\n    def _decompose(self):\n        \"\"\"\n        See also\n        --------\n        dwt2 : for 2D Discrete Wavelet Transform output coefficients.\n        \"\"\"\n        if self.is_empty:\n            data_ll, data_lh, data_hl, data_hh = None, None, None, None\n        else:\n            data_ll, (data_hl, data_lh, data_hh) =\\\n                dwt2(self.data, self.wavelet, self.mode, axes=self.axes)\n        self._create_subnode(self.LL, data_ll)\n        self._create_subnode(self.LH, data_lh)\n        self._create_subnode(self.HL, data_hl)\n        self._create_subnode(self.HH, data_hh)\n        return (self._get_node(self.LL), self._get_node(self.HL),\n                self._get_node(self.LH), self._get_node(self.HH))\n\n    def _reconstruct(self, update):\n        data_ll, data_lh, data_hl, data_hh = None, None, None, None\n\n        node_ll, node_lh, node_hl, node_hh =\\\n            self._get_node(self.LL), self._get_node(self.LH),\\\n            self._get_node(self.HL), self._get_node(self.HH)\n\n        if node_ll is not None:\n            data_ll = node_ll.reconstruct()\n        if node_lh is not None:\n            data_lh = node_lh.reconstruct()\n        if node_hl is not None:\n            data_hl = node_hl.reconstruct()\n        if node_hh is not None:\n            data_hh = node_hh.reconstruct()\n\n        if (data_ll is None and data_lh is None and\n                data_hl is None and data_hh is None):\n            raise ValueError(\n                \"Tree is missing data - all subnodes of `%s` node \"\n                \"are None. Cannot reconstruct node.\" % self.path\n            )\n        else:\n            coeffs = data_ll, (data_hl, data_lh, data_hh)\n            rec = idwt2(coeffs, self.wavelet, self.mode, axes=self.axes)\n            if self._data_shape is not None and (\n                    rec.shape != self._data_shape):\n                rec = rec[tuple([slice(sz) for sz in self._data_shape])]\n            if update:\n                self.data = rec\n            return rec\n\n    def expand_2d_path(self, path):\n        expanded_paths = {\n            self.HH: 'hh',\n            self.HL: 'hl',\n            self.LH: 'lh',\n            self.LL: 'll'\n        }\n        return (''.join([expanded_paths[p][0] for p in path]),\n                ''.join([expanded_paths[p][1] for p in path]))\n</code></pre>"},{"location":"ref/#pywt.NodeND","title":"<code>NodeND</code>","text":"<p>               Bases: <code>BaseNode</code></p> <p>WaveletPacket tree node.</p> <p>Unlike Node and Node2D self.PARTS is a dictionary. For 1D:  self.PARTS has keys 'a' and 'd' For 2D:  self.PARTS has keys 'aa', 'ad', 'da', 'dd' For 3D:  self.PARTS has keys 'aaa', 'aad', 'ada', 'daa', ..., 'ddd'</p>"},{"location":"ref/#pywt.NodeND--parameters","title":"Parameters","text":"<p>parent :     Parent node. If parent is None then the node is considered detached     (ie root). data : 1D or 2D array     Data associated with the node. 1D or 2D numeric array, depending on the     transform type. node_name : string     A name identifying the coefficients type.     See <code>Node.node_name</code> and <code>Node2D.node_name</code>     for information on the accepted subnodes names. ndim : int     The number of data dimensions. ndim_transform : int     The number of dimensions that are to be transformed.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class NodeND(BaseNode):\n    \"\"\"\n    WaveletPacket tree node.\n\n    Unlike Node and Node2D self.PARTS is a dictionary.\n    For 1D:  self.PARTS has keys 'a' and 'd'\n    For 2D:  self.PARTS has keys 'aa', 'ad', 'da', 'dd'\n    For 3D:  self.PARTS has keys 'aaa', 'aad', 'ada', 'daa', ..., 'ddd'\n\n    Parameters\n    ----------\n    parent :\n        Parent node. If parent is None then the node is considered detached\n        (ie root).\n    data : 1D or 2D array\n        Data associated with the node. 1D or 2D numeric array, depending on the\n        transform type.\n    node_name : string\n        A name identifying the coefficients type.\n        See `Node.node_name` and `Node2D.node_name`\n        for information on the accepted subnodes names.\n    ndim : int\n        The number of data dimensions.\n    ndim_transform : int\n        The number of dimensions that are to be transformed.\n\n    \"\"\"\n    def __init__(self, parent, data, node_name, ndim, ndim_transform):\n        super().__init__(parent=parent, data=data,\n                                     node_name=node_name)\n        self.PART_LEN = ndim_transform\n        self.PARTS = OrderedDict()\n        for key in product(*(('ad', )*self.PART_LEN)):\n            self.PARTS[''.join(key)] = None\n        self.ndim = ndim\n        self.ndim_transform = ndim_transform\n\n    def _init_subnodes(self):\n        # need this empty so BaseNode's _init_subnodes isn't called during\n        # __init__.  We use a dictionary for PARTS instead for the nd case.\n        pass\n\n    def _get_node(self, part):\n        return self.PARTS[part]\n\n    def _set_node(self, part, node):\n        if part not in self.PARTS:\n            raise ValueError(\"invalid part\")\n        self.PARTS[part] = node\n\n    def _delete_node(self, part):\n        self._set_node(part, None)\n\n    def _validate_node_name(self, part):\n        if part not in self.PARTS:\n            raise ValueError(\n                \"Subnode name must be in [{}], not '{}'.\".format(', '.join(\"'%s'\" % p for p in list(self.PARTS.keys())), part))\n\n    def _create_subnode(self, part, data=None, overwrite=True):\n        return self._create_subnode_base(node_cls=NodeND, part=part, data=data,\n                                         overwrite=overwrite, ndim=self.ndim,\n                                         ndim_transform=self.ndim_transform)\n\n    def _evaluate_maxlevel(self, evaluate_from='parent'):\n        \"\"\"\n        Try to find the value of maximum decomposition level if it is not\n        specified explicitly.\n\n        Parameters\n        ----------\n        evaluate_from : {'parent', 'subnodes'}\n        \"\"\"\n        assert evaluate_from in ('parent', 'subnodes')\n\n        if self._maxlevel is not None:\n            return self._maxlevel\n        elif self.data is not None:\n            return self.level + dwt_max_level(\n                min(self.data.shape), self.wavelet)\n\n        if evaluate_from == 'parent':\n            if self.parent is not None:\n                return self.parent._evaluate_maxlevel(evaluate_from)\n        elif evaluate_from == 'subnodes':\n            for node_name, node in self.PARTS.items():\n                if node is not None:\n                    level = node._evaluate_maxlevel(evaluate_from)\n                    if level is not None:\n                        return level\n        return None\n\n    def _decompose(self):\n        \"\"\"\n        See also\n        --------\n        dwt2 : for 2D Discrete Wavelet Transform output coefficients.\n        \"\"\"\n        if self.is_empty:\n            coefs = {key: None for key in self.PARTS}\n        else:\n            coefs = dwtn(self.data, self.wavelet, self.mode, axes=self.axes)\n\n        for key, data in coefs.items():\n            self._create_subnode(key, data)\n        return (self._get_node(key) for key in self.PARTS)\n\n    def _reconstruct(self, update):\n        coeffs = {key: None for key in self.PARTS}\n\n        nnodes = 0\n        for key in self.PARTS:\n            node = self._get_node(key)\n            if node is not None:\n                nnodes += 1\n                coeffs[key] = node.reconstruct()\n\n        if nnodes == 0:\n            raise ValueError(\n                \"Tree is missing data - all subnodes of `%s` node \"\n                \"are None. Cannot reconstruct node.\" % self.path\n            )\n        else:\n            rec = idwtn(coeffs, self.wavelet, self.mode, axes=self.axes)\n            if update:\n                self.data = rec\n            return rec\n</code></pre>"},{"location":"ref/#pywt.WaveletPacket","title":"<code>WaveletPacket</code>","text":"<p>               Bases: <code>Node</code></p> <p>Data structure representing Wavelet Packet decomposition of signal.</p>"},{"location":"ref/#pywt.WaveletPacket--parameters","title":"Parameters","text":"<p>data : 1D ndarray     Original data (signal) wavelet : Wavelet object or name string     Wavelet used in DWT decomposition and reconstruction mode : str, optional     Signal extension mode for the <code>dwt</code> and <code>idwt</code> decomposition and     reconstruction functions. maxlevel : int, optional     Maximum level of decomposition.     If None, it will be calculated based on the <code>wavelet</code> and <code>data</code>     length using <code>pywt.dwt_max_level</code>. axis : int, optional     The axis to transform.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class WaveletPacket(Node):\n    \"\"\"\n    Data structure representing Wavelet Packet decomposition of signal.\n\n    Parameters\n    ----------\n    data : 1D ndarray\n        Original data (signal)\n    wavelet : Wavelet object or name string\n        Wavelet used in DWT decomposition and reconstruction\n    mode : str, optional\n        Signal extension mode for the `dwt` and `idwt` decomposition and\n        reconstruction functions.\n    maxlevel : int, optional\n        Maximum level of decomposition.\n        If None, it will be calculated based on the `wavelet` and `data`\n        length using `pywt.dwt_max_level`.\n    axis : int, optional\n        The axis to transform.\n    \"\"\"\n    def __init__(self, data, wavelet, mode='symmetric', maxlevel=None,\n                 axis=-1):\n        super().__init__(None, data, \"\")\n\n        if not isinstance(wavelet, Wavelet):\n            wavelet = Wavelet(wavelet)\n        self.wavelet = wavelet\n        self.mode = mode\n        self.axes = axis  # self.axes is just an integer for 1D transforms\n\n        if data is not None:\n            data = np.asarray(data)\n            if self.axes &lt; 0:\n                self.axes = self.axes + data.ndim\n            if not 0 &lt;= self.axes &lt; data.ndim:\n                raise ValueError(\"Axis greater than data dimensions\")\n            self.data_size = data.shape\n            if maxlevel is None:\n                maxlevel = dwt_max_level(data.shape[self.axes], self.wavelet)\n        else:\n            self.data_size = None\n\n        self._maxlevel = maxlevel\n\n    def __reduce__(self):\n        return (WaveletPacket,\n                (self.data, self.wavelet, self.mode, self.maxlevel))\n\n    def reconstruct(self, update=True):\n        \"\"\"\n        Reconstruct data value using coefficients from subnodes.\n\n        Parameters\n        ----------\n        update : bool, optional\n            If True (default), then data values will be replaced by\n            reconstruction values, also in subnodes.\n        \"\"\"\n        if self.has_any_subnode:\n            data = super().reconstruct(update)\n            if self.data_size is not None and (data.shape != self.data_size):\n                data = data[[slice(sz) for sz in self.data_size]]\n            if update:\n                self.data = data\n            return data\n        return self.data  # return original data\n\n    def get_level(self, level, order=\"natural\", decompose=True):\n        \"\"\"\n        Returns all nodes on the specified level.\n\n        Parameters\n        ----------\n        level : int\n            Specifies decomposition `level` from which the nodes will be\n            collected.\n        order : {'natural', 'freq'}, optional\n            - \"natural\" - left to right in tree (default)\n            - \"freq\" - band ordered\n        decompose : bool, optional\n            If set then the method will try to decompose the data up\n            to the specified `level` (default: True).\n\n        Notes\n        -----\n        If nodes at the given level are missing (i.e. the tree is partially\n        decomposed) and `decompose` is set to False, only existing nodes\n        will be returned.\n\n        Frequency order (``order=\"freq\"``) is also known as sequency order\n        and \"natural\" order is sometimes referred to as Paley order. A detailed\n        discussion of these orderings is also given in [1]_, [2]_.\n\n        References\n        ----------\n        ..[1] M.V. Wickerhauser. Adapted Wavelet Analysis from Theory to\n              Software. Wellesley. Massachusetts: A K Peters. 1994.\n        ..[2] D.B. Percival and A.T. Walden.  Wavelet Methods for Time Series\n              Analysis. Cambridge University Press. 2000.\n              DOI:10.1017/CBO9780511841040\n        \"\"\"\n        if order not in [\"natural\", \"freq\"]:\n            raise ValueError(f\"Invalid order: {order}\")\n        if level &gt; self.maxlevel:\n            raise ValueError(\"The level cannot be greater than the maximum\"\n                             \" decomposition level value (%d)\" % self.maxlevel)\n\n        result = []\n\n        def collect(node):\n            if node.level == level:\n                result.append(node)\n                return False\n            return True\n\n        self.walk(collect, decompose=decompose)\n        if order == \"natural\":\n            return result\n        elif order == \"freq\":\n            result = {node.path: node for node in result}\n            graycode_order = get_graycode_order(level)\n            return [result[path] for path in graycode_order if path in result]\n        else:\n            raise ValueError(f\"Invalid order name - {order}.\")\n</code></pre>"},{"location":"ref/#pywt.WaveletPacket.get_level","title":"<code>get_level(level, order='natural', decompose=True)</code>","text":"<p>Returns all nodes on the specified level.</p>"},{"location":"ref/#pywt.WaveletPacket.get_level--parameters","title":"Parameters","text":"<p>level : int     Specifies decomposition <code>level</code> from which the nodes will be     collected. order : {'natural', 'freq'}, optional     - \"natural\" - left to right in tree (default)     - \"freq\" - band ordered decompose : bool, optional     If set then the method will try to decompose the data up     to the specified <code>level</code> (default: True).</p>"},{"location":"ref/#pywt.WaveletPacket.get_level--notes","title":"Notes","text":"<p>If nodes at the given level are missing (i.e. the tree is partially decomposed) and <code>decompose</code> is set to False, only existing nodes will be returned.</p> <p>Frequency order (<code>order=\"freq\"</code>) is also known as sequency order and \"natural\" order is sometimes referred to as Paley order. A detailed discussion of these orderings is also given in [1], [2].</p>"},{"location":"ref/#pywt.WaveletPacket.get_level--references","title":"References","text":"<p>..[1] M.V. Wickerhauser. Adapted Wavelet Analysis from Theory to       Software. Wellesley. Massachusetts: A K Peters. 1994. ..[2] D.B. Percival and A.T. Walden.  Wavelet Methods for Time Series       Analysis. Cambridge University Press. 2000.       DOI:10.1017/CBO9780511841040</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def get_level(self, level, order=\"natural\", decompose=True):\n    \"\"\"\n    Returns all nodes on the specified level.\n\n    Parameters\n    ----------\n    level : int\n        Specifies decomposition `level` from which the nodes will be\n        collected.\n    order : {'natural', 'freq'}, optional\n        - \"natural\" - left to right in tree (default)\n        - \"freq\" - band ordered\n    decompose : bool, optional\n        If set then the method will try to decompose the data up\n        to the specified `level` (default: True).\n\n    Notes\n    -----\n    If nodes at the given level are missing (i.e. the tree is partially\n    decomposed) and `decompose` is set to False, only existing nodes\n    will be returned.\n\n    Frequency order (``order=\"freq\"``) is also known as sequency order\n    and \"natural\" order is sometimes referred to as Paley order. A detailed\n    discussion of these orderings is also given in [1]_, [2]_.\n\n    References\n    ----------\n    ..[1] M.V. Wickerhauser. Adapted Wavelet Analysis from Theory to\n          Software. Wellesley. Massachusetts: A K Peters. 1994.\n    ..[2] D.B. Percival and A.T. Walden.  Wavelet Methods for Time Series\n          Analysis. Cambridge University Press. 2000.\n          DOI:10.1017/CBO9780511841040\n    \"\"\"\n    if order not in [\"natural\", \"freq\"]:\n        raise ValueError(f\"Invalid order: {order}\")\n    if level &gt; self.maxlevel:\n        raise ValueError(\"The level cannot be greater than the maximum\"\n                         \" decomposition level value (%d)\" % self.maxlevel)\n\n    result = []\n\n    def collect(node):\n        if node.level == level:\n            result.append(node)\n            return False\n        return True\n\n    self.walk(collect, decompose=decompose)\n    if order == \"natural\":\n        return result\n    elif order == \"freq\":\n        result = {node.path: node for node in result}\n        graycode_order = get_graycode_order(level)\n        return [result[path] for path in graycode_order if path in result]\n    else:\n        raise ValueError(f\"Invalid order name - {order}.\")\n</code></pre>"},{"location":"ref/#pywt.WaveletPacket.reconstruct","title":"<code>reconstruct(update=True)</code>","text":"<p>Reconstruct data value using coefficients from subnodes.</p>"},{"location":"ref/#pywt.WaveletPacket.reconstruct--parameters","title":"Parameters","text":"<p>update : bool, optional     If True (default), then data values will be replaced by     reconstruction values, also in subnodes.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def reconstruct(self, update=True):\n    \"\"\"\n    Reconstruct data value using coefficients from subnodes.\n\n    Parameters\n    ----------\n    update : bool, optional\n        If True (default), then data values will be replaced by\n        reconstruction values, also in subnodes.\n    \"\"\"\n    if self.has_any_subnode:\n        data = super().reconstruct(update)\n        if self.data_size is not None and (data.shape != self.data_size):\n            data = data[[slice(sz) for sz in self.data_size]]\n        if update:\n            self.data = data\n        return data\n    return self.data  # return original data\n</code></pre>"},{"location":"ref/#pywt.WaveletPacket2D","title":"<code>WaveletPacket2D</code>","text":"<p>               Bases: <code>Node2D</code></p> <p>Data structure representing 2D Wavelet Packet decomposition of signal.</p>"},{"location":"ref/#pywt.WaveletPacket2D--parameters","title":"Parameters","text":"<p>data : 2D ndarray     Data associated with the node. wavelet : Wavelet object or name string     Wavelet used in DWT decomposition and reconstruction mode : str, optional     Signal extension mode for the <code>dwt</code> and <code>idwt</code> decomposition and     reconstruction functions. maxlevel : int     Maximum level of decomposition.     If None, it will be calculated based on the <code>wavelet</code> and <code>data</code>     length using <code>pywt.dwt_max_level</code>. axes : 2-tuple of ints, optional     The axes that will be transformed.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class WaveletPacket2D(Node2D):\n    \"\"\"\n    Data structure representing 2D Wavelet Packet decomposition of signal.\n\n    Parameters\n    ----------\n    data : 2D ndarray\n        Data associated with the node.\n    wavelet : Wavelet object or name string\n        Wavelet used in DWT decomposition and reconstruction\n    mode : str, optional\n        Signal extension mode for the `dwt` and `idwt` decomposition and\n        reconstruction functions.\n    maxlevel : int\n        Maximum level of decomposition.\n        If None, it will be calculated based on the `wavelet` and `data`\n        length using `pywt.dwt_max_level`.\n    axes : 2-tuple of ints, optional\n        The axes that will be transformed.\n    \"\"\"\n    def __init__(self, data, wavelet, mode='smooth', maxlevel=None,\n                 axes=(-2, -1)):\n        super().__init__(None, data, \"\")\n\n        if not isinstance(wavelet, Wavelet):\n            wavelet = Wavelet(wavelet)\n        self.wavelet = wavelet\n        self.mode = mode\n        self.axes = tuple(axes)\n        if len(np.unique(self.axes)) != 2:\n            raise ValueError(\"Expected two unique axes.\")\n        if data is not None:\n            data = np.asarray(data)\n            if data.ndim &lt; 2:\n                raise ValueError(\n                    \"WaveletPacket2D requires data with 2 or more dimensions.\")\n            self.data_size = data.shape\n            transform_size = [data.shape[ax] for ax in self.axes]\n            if maxlevel is None:\n                maxlevel = dwt_max_level(min(transform_size), self.wavelet)\n        else:\n            self.data_size = None\n        self._maxlevel = maxlevel\n\n    def __reduce__(self):\n        return (WaveletPacket2D,\n                (self.data, self.wavelet, self.mode, self.maxlevel))\n\n    def reconstruct(self, update=True):\n        \"\"\"\n        Reconstruct data using coefficients from subnodes.\n\n        Parameters\n        ----------\n        update : bool, optional\n            If True (default) then the coefficients of the current node\n            and its subnodes will be replaced with values from reconstruction.\n        \"\"\"\n        if self.has_any_subnode:\n            data = super().reconstruct(update)\n            if self.data_size is not None and (data.shape != self.data_size):\n                data = data[[slice(sz) for sz in self.data_size]]\n            if update:\n                self.data = data\n            return data\n        return self.data  # return original data\n\n    def get_level(self, level, order=\"natural\", decompose=True):\n        \"\"\"\n        Returns all nodes from specified level.\n\n        Parameters\n        ----------\n        level : int\n            Decomposition `level` from which the nodes will be\n            collected.\n        order : {'natural', 'freq'}, optional\n            If `natural` (default) a flat list is returned.\n            If `freq`, a 2d structure with rows and cols\n            sorted by corresponding dimension frequency of 2d\n            coefficient array (adapted from 1d case).\n        decompose : bool, optional\n            If set then the method will try to decompose the data up\n            to the specified `level` (default: True).\n\n        Notes\n        -----\n        Frequency order (``order=\"freq\"``) is also known as as sequency order\n        and \"natural\" order is sometimes referred to as Paley order. A detailed\n        discussion of these orderings is also given in [1]_, [2]_.\n\n        References\n        ----------\n        ..[1] M.V. Wickerhauser. Adapted Wavelet Analysis from Theory to\n              Software. Wellesley. Massachusetts: A K Peters. 1994.\n        ..[2] D.B. Percival and A.T. Walden.  Wavelet Methods for Time Series\n              Analysis. Cambridge University Press. 2000.\n              DOI:10.1017/CBO9780511841040\n        \"\"\"\n        if order not in [\"natural\", \"freq\"]:\n            raise ValueError(f\"Invalid order: {order}\")\n        if level &gt; self.maxlevel:\n            raise ValueError(\"The level cannot be greater than the maximum\"\n                             \" decomposition level value (%d)\" % self.maxlevel)\n\n        result = []\n\n        def collect(node):\n            if node.level == level:\n                result.append(node)\n                return False\n            return True\n\n        self.walk(collect, decompose=decompose)\n\n        if order == \"freq\":\n            nodes = {}\n            for (row_path, col_path), node in [\n                (self.expand_2d_path(node.path), node) for node in result\n            ]:\n                nodes.setdefault(row_path, {})[col_path] = node\n            graycode_order = get_graycode_order(level, x='l', y='h')\n            nodes = [nodes[path] for path in graycode_order if path in nodes]\n            result = []\n            for row in nodes:\n                result.append(\n                    [row[path] for path in graycode_order if path in row]\n                )\n        return result\n</code></pre>"},{"location":"ref/#pywt.WaveletPacket2D.get_level","title":"<code>get_level(level, order='natural', decompose=True)</code>","text":"<p>Returns all nodes from specified level.</p>"},{"location":"ref/#pywt.WaveletPacket2D.get_level--parameters","title":"Parameters","text":"<p>level : int     Decomposition <code>level</code> from which the nodes will be     collected. order : {'natural', 'freq'}, optional     If <code>natural</code> (default) a flat list is returned.     If <code>freq</code>, a 2d structure with rows and cols     sorted by corresponding dimension frequency of 2d     coefficient array (adapted from 1d case). decompose : bool, optional     If set then the method will try to decompose the data up     to the specified <code>level</code> (default: True).</p>"},{"location":"ref/#pywt.WaveletPacket2D.get_level--notes","title":"Notes","text":"<p>Frequency order (<code>order=\"freq\"</code>) is also known as as sequency order and \"natural\" order is sometimes referred to as Paley order. A detailed discussion of these orderings is also given in [1], [2].</p>"},{"location":"ref/#pywt.WaveletPacket2D.get_level--references","title":"References","text":"<p>..[1] M.V. Wickerhauser. Adapted Wavelet Analysis from Theory to       Software. Wellesley. Massachusetts: A K Peters. 1994. ..[2] D.B. Percival and A.T. Walden.  Wavelet Methods for Time Series       Analysis. Cambridge University Press. 2000.       DOI:10.1017/CBO9780511841040</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def get_level(self, level, order=\"natural\", decompose=True):\n    \"\"\"\n    Returns all nodes from specified level.\n\n    Parameters\n    ----------\n    level : int\n        Decomposition `level` from which the nodes will be\n        collected.\n    order : {'natural', 'freq'}, optional\n        If `natural` (default) a flat list is returned.\n        If `freq`, a 2d structure with rows and cols\n        sorted by corresponding dimension frequency of 2d\n        coefficient array (adapted from 1d case).\n    decompose : bool, optional\n        If set then the method will try to decompose the data up\n        to the specified `level` (default: True).\n\n    Notes\n    -----\n    Frequency order (``order=\"freq\"``) is also known as as sequency order\n    and \"natural\" order is sometimes referred to as Paley order. A detailed\n    discussion of these orderings is also given in [1]_, [2]_.\n\n    References\n    ----------\n    ..[1] M.V. Wickerhauser. Adapted Wavelet Analysis from Theory to\n          Software. Wellesley. Massachusetts: A K Peters. 1994.\n    ..[2] D.B. Percival and A.T. Walden.  Wavelet Methods for Time Series\n          Analysis. Cambridge University Press. 2000.\n          DOI:10.1017/CBO9780511841040\n    \"\"\"\n    if order not in [\"natural\", \"freq\"]:\n        raise ValueError(f\"Invalid order: {order}\")\n    if level &gt; self.maxlevel:\n        raise ValueError(\"The level cannot be greater than the maximum\"\n                         \" decomposition level value (%d)\" % self.maxlevel)\n\n    result = []\n\n    def collect(node):\n        if node.level == level:\n            result.append(node)\n            return False\n        return True\n\n    self.walk(collect, decompose=decompose)\n\n    if order == \"freq\":\n        nodes = {}\n        for (row_path, col_path), node in [\n            (self.expand_2d_path(node.path), node) for node in result\n        ]:\n            nodes.setdefault(row_path, {})[col_path] = node\n        graycode_order = get_graycode_order(level, x='l', y='h')\n        nodes = [nodes[path] for path in graycode_order if path in nodes]\n        result = []\n        for row in nodes:\n            result.append(\n                [row[path] for path in graycode_order if path in row]\n            )\n    return result\n</code></pre>"},{"location":"ref/#pywt.WaveletPacket2D.reconstruct","title":"<code>reconstruct(update=True)</code>","text":"<p>Reconstruct data using coefficients from subnodes.</p>"},{"location":"ref/#pywt.WaveletPacket2D.reconstruct--parameters","title":"Parameters","text":"<p>update : bool, optional     If True (default) then the coefficients of the current node     and its subnodes will be replaced with values from reconstruction.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def reconstruct(self, update=True):\n    \"\"\"\n    Reconstruct data using coefficients from subnodes.\n\n    Parameters\n    ----------\n    update : bool, optional\n        If True (default) then the coefficients of the current node\n        and its subnodes will be replaced with values from reconstruction.\n    \"\"\"\n    if self.has_any_subnode:\n        data = super().reconstruct(update)\n        if self.data_size is not None and (data.shape != self.data_size):\n            data = data[[slice(sz) for sz in self.data_size]]\n        if update:\n            self.data = data\n        return data\n    return self.data  # return original data\n</code></pre>"},{"location":"ref/#pywt.WaveletPacketND","title":"<code>WaveletPacketND</code>","text":"<p>               Bases: <code>NodeND</code></p> <p>Data structure representing ND Wavelet Packet decomposition of signal.</p>"},{"location":"ref/#pywt.WaveletPacketND--parameters","title":"Parameters","text":"<p>data : ND ndarray     Data associated with the node. wavelet : Wavelet object or name string     Wavelet used in DWT decomposition and reconstruction mode : str, optional     Signal extension mode for the <code>dwt</code> and <code>idwt</code> decomposition and     reconstruction functions. maxlevel : int, optional     Maximum level of decomposition.     If None, it will be calculated based on the <code>wavelet</code> and <code>data</code>     length using <code>pywt.dwt_max_level</code>. axes : tuple of int, optional     The axes to transform.  The default value of <code>None</code> corresponds to all     axes.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>class WaveletPacketND(NodeND):\n    \"\"\"\n    Data structure representing ND Wavelet Packet decomposition of signal.\n\n    Parameters\n    ----------\n    data : ND ndarray\n        Data associated with the node.\n    wavelet : Wavelet object or name string\n        Wavelet used in DWT decomposition and reconstruction\n    mode : str, optional\n        Signal extension mode for the `dwt` and `idwt` decomposition and\n        reconstruction functions.\n    maxlevel : int, optional\n        Maximum level of decomposition.\n        If None, it will be calculated based on the `wavelet` and `data`\n        length using `pywt.dwt_max_level`.\n    axes : tuple of int, optional\n        The axes to transform.  The default value of `None` corresponds to all\n        axes.\n    \"\"\"\n    def __init__(self, data, wavelet, mode='smooth', maxlevel=None,\n                 axes=None):\n        if (data is None) and (axes is None):\n            # ndim is required to create a NodeND object\n            raise ValueError(\"If data is None, axes must be specified\")\n\n        # axes determines the number of transform dimensions\n        if axes is None:\n            axes = range(data.ndim)\n        elif np.isscalar(axes):\n            axes = (axes, )\n        axes = tuple(axes)\n        if len(np.unique(axes)) != len(axes):\n            raise ValueError(\"Expected a set of unique axes.\")\n        ndim_transform = len(axes)\n\n        if data is not None:\n            data = np.asarray(data)\n            if data.ndim == 0:\n                raise ValueError(\"data must be at least 1D\")\n            ndim = data.ndim\n        else:\n            ndim = len(axes)\n\n        super().__init__(None, data, \"\", ndim,\n                                              ndim_transform)\n        if not isinstance(wavelet, Wavelet):\n            wavelet = Wavelet(wavelet)\n        self.wavelet = wavelet\n        self.mode = mode\n        self.axes = axes\n        self.ndim_transform = ndim_transform\n        if data is not None:\n            if data.ndim &lt; len(axes):\n                raise ValueError(\"The number of axes exceeds the number of \"\n                                 \"data dimensions.\")\n            self.data_size = data.shape\n            transform_size = [data.shape[ax] for ax in self.axes]\n            if maxlevel is None:\n                maxlevel = dwt_max_level(min(transform_size), self.wavelet)\n        else:\n            self.data_size = None\n        self._maxlevel = maxlevel\n\n    def reconstruct(self, update=True):\n        \"\"\"\n        Reconstruct data using coefficients from subnodes.\n\n        Parameters\n        ----------\n        update : bool, optional\n            If True (default) then the coefficients of the current node\n            and its subnodes will be replaced with values from reconstruction.\n        \"\"\"\n        if self.has_any_subnode:\n            data = super().reconstruct(update)\n            if self.data_size is not None and (data.shape != self.data_size):\n                data = data[[slice(sz) for sz in self.data_size]]\n            if update:\n                self.data = data\n            return data\n        return self.data  # return original data\n\n    def get_level(self, level, decompose=True):\n        \"\"\"\n        Returns all nodes from specified level.\n\n        Parameters\n        ----------\n        level : int\n            Decomposition `level` from which the nodes will be\n            collected.\n        decompose : bool, optional\n            If set then the method will try to decompose the data up\n            to the specified `level` (default: True).\n        \"\"\"\n        if level &gt; self.maxlevel:\n            raise ValueError(\"The level cannot be greater than the maximum\"\n                             \" decomposition level value (%d)\" % self.maxlevel)\n\n        result = []\n\n        def collect(node):\n            if node.level == level:\n                result.append(node)\n                return False\n            return True\n\n        self.walk(collect, decompose=decompose)\n\n        return result\n</code></pre>"},{"location":"ref/#pywt.WaveletPacketND.get_level","title":"<code>get_level(level, decompose=True)</code>","text":"<p>Returns all nodes from specified level.</p>"},{"location":"ref/#pywt.WaveletPacketND.get_level--parameters","title":"Parameters","text":"<p>level : int     Decomposition <code>level</code> from which the nodes will be     collected. decompose : bool, optional     If set then the method will try to decompose the data up     to the specified <code>level</code> (default: True).</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def get_level(self, level, decompose=True):\n    \"\"\"\n    Returns all nodes from specified level.\n\n    Parameters\n    ----------\n    level : int\n        Decomposition `level` from which the nodes will be\n        collected.\n    decompose : bool, optional\n        If set then the method will try to decompose the data up\n        to the specified `level` (default: True).\n    \"\"\"\n    if level &gt; self.maxlevel:\n        raise ValueError(\"The level cannot be greater than the maximum\"\n                         \" decomposition level value (%d)\" % self.maxlevel)\n\n    result = []\n\n    def collect(node):\n        if node.level == level:\n            result.append(node)\n            return False\n        return True\n\n    self.walk(collect, decompose=decompose)\n\n    return result\n</code></pre>"},{"location":"ref/#pywt.WaveletPacketND.reconstruct","title":"<code>reconstruct(update=True)</code>","text":"<p>Reconstruct data using coefficients from subnodes.</p>"},{"location":"ref/#pywt.WaveletPacketND.reconstruct--parameters","title":"Parameters","text":"<p>update : bool, optional     If True (default) then the coefficients of the current node     and its subnodes will be replaced with values from reconstruction.</p> Source code in <code>pywt/_wavelet_packets.py</code> <pre><code>def reconstruct(self, update=True):\n    \"\"\"\n    Reconstruct data using coefficients from subnodes.\n\n    Parameters\n    ----------\n    update : bool, optional\n        If True (default) then the coefficients of the current node\n        and its subnodes will be replaced with values from reconstruction.\n    \"\"\"\n    if self.has_any_subnode:\n        data = super().reconstruct(update)\n        if self.data_size is not None and (data.shape != self.data_size):\n            data = data[[slice(sz) for sz in self.data_size]]\n        if update:\n            self.data = data\n        return data\n    return self.data  # return original data\n</code></pre>"},{"location":"ref/#pywt.array_to_coeffs","title":"<code>array_to_coeffs(arr, coeff_slices, output_format='wavedecn')</code>","text":"<p>Convert a combined array of coefficients back to a list compatible with <code>waverecn</code>.</p>"},{"location":"ref/#pywt.array_to_coeffs--parameters","title":"Parameters","text":"array-like <p>An array containing all wavelet coefficients.  This should have been generated via <code>coeffs_to_array</code>.</p> <p>coeff_slices : list of tuples     List of slices corresponding to each coefficient as obtained from     <code>array_to_coeffs</code>. output_format : {'wavedec', 'wavedec2', 'wavedecn'}     Make the form of the coefficients compatible with this type of     multilevel transform.</p>"},{"location":"ref/#pywt.array_to_coeffs--returns","title":"Returns","text":"<p>coeffs: array-like     Wavelet transform coefficient array.</p>"},{"location":"ref/#pywt.array_to_coeffs--see-also","title":"See Also","text":"<p>coeffs_to_array : the inverse of array_to_coeffs</p>"},{"location":"ref/#pywt.array_to_coeffs--notes","title":"Notes","text":"<p>A single large array containing all coefficients will have subsets stored, into a <code>waverecn</code> list, c, as indicated below::</p> <pre><code>+---------------+---------------+-------------------------------+\n|               |               |                               |\n|     c[0]      |  c[1]['da']   |                               |\n|               |               |                               |\n+---------------+---------------+           c[2]['da']          |\n|               |               |                               |\n| c[1]['ad']    |  c[1]['dd']   |                               |\n|               |               |                               |\n+---------------+---------------+ ------------------------------+\n|                               |                               |\n|                               |                               |\n|                               |                               |\n|          c[2]['ad']           |           c[2]['dd']          |\n|                               |                               |\n|                               |                               |\n|                               |                               |\n+-------------------------------+-------------------------------+\n</code></pre>"},{"location":"ref/#pywt.array_to_coeffs--examples","title":"Examples","text":"<p>import pywt from numpy.testing import assert_array_almost_equal cam = pywt.data.camera() coeffs = pywt.wavedecn(cam, wavelet='db2', level=3) arr, coeff_slices = pywt.coeffs_to_array(coeffs) coeffs_from_arr = pywt.array_to_coeffs(arr, coeff_slices, ...                                        output_format='wavedecn') cam_recon = pywt.waverecn(coeffs_from_arr, wavelet='db2') assert_array_almost_equal(cam, cam_recon)</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def array_to_coeffs(arr, coeff_slices, output_format='wavedecn'):\n    \"\"\"\n    Convert a combined array of coefficients back to a list compatible with\n    ``waverecn``.\n\n    Parameters\n    ----------\n\n    arr : array-like\n        An array containing all wavelet coefficients.  This should have been\n        generated via ``coeffs_to_array``.\n    coeff_slices : list of tuples\n        List of slices corresponding to each coefficient as obtained from\n        ``array_to_coeffs``.\n    output_format : {'wavedec', 'wavedec2', 'wavedecn'}\n        Make the form of the coefficients compatible with this type of\n        multilevel transform.\n\n    Returns\n    -------\n    coeffs: array-like\n        Wavelet transform coefficient array.\n\n    See Also\n    --------\n    coeffs_to_array : the inverse of array_to_coeffs\n\n    Notes\n    -----\n    A single large array containing all coefficients will have subsets stored,\n    into a ``waverecn`` list, c, as indicated below::\n\n        +---------------+---------------+-------------------------------+\n        |               |               |                               |\n        |     c[0]      |  c[1]['da']   |                               |\n        |               |               |                               |\n        +---------------+---------------+           c[2]['da']          |\n        |               |               |                               |\n        | c[1]['ad']    |  c[1]['dd']   |                               |\n        |               |               |                               |\n        +---------------+---------------+ ------------------------------+\n        |                               |                               |\n        |                               |                               |\n        |                               |                               |\n        |          c[2]['ad']           |           c[2]['dd']          |\n        |                               |                               |\n        |                               |                               |\n        |                               |                               |\n        +-------------------------------+-------------------------------+\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; from numpy.testing import assert_array_almost_equal\n    &gt;&gt;&gt; cam = pywt.data.camera()\n    &gt;&gt;&gt; coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n    &gt;&gt;&gt; arr, coeff_slices = pywt.coeffs_to_array(coeffs)\n    &gt;&gt;&gt; coeffs_from_arr = pywt.array_to_coeffs(arr, coeff_slices,\n    ...                                        output_format='wavedecn')\n    &gt;&gt;&gt; cam_recon = pywt.waverecn(coeffs_from_arr, wavelet='db2')\n    &gt;&gt;&gt; assert_array_almost_equal(cam, cam_recon)\n\n    \"\"\"\n    arr = np.asarray(arr)\n    coeffs = []\n    if len(coeff_slices) == 0:\n        raise ValueError(\"empty list of coefficient slices\")\n    else:\n        coeffs.append(arr[coeff_slices[0]])\n\n    # difference coefficients at each level\n    for n in range(1, len(coeff_slices)):\n        if output_format == 'wavedec':\n            d = arr[coeff_slices[n]['d']]\n        elif output_format == 'wavedec2':\n            d = (arr[coeff_slices[n]['da']],\n                 arr[coeff_slices[n]['ad']],\n                 arr[coeff_slices[n]['dd']])\n        elif output_format == 'wavedecn':\n            d = {}\n            for k, v in coeff_slices[n].items():\n                d[k] = arr[v]\n        else:\n            raise ValueError(\n                f\"Unrecognized output format: {output_format}\")\n        coeffs.append(d)\n    return coeffs\n</code></pre>"},{"location":"ref/#pywt.central_frequency","title":"<code>central_frequency(wavelet, precision=8)</code>","text":"<p>Computes the central frequency of the <code>psi</code> wavelet function.</p>"},{"location":"ref/#pywt.central_frequency--parameters","title":"Parameters","text":"<p>wavelet : Wavelet instance, str or tuple     Wavelet to integrate.  If a string, should be the name of a wavelet. precision : int, optional     Precision that will be used for wavelet function     approximation computed with the wavefun(level=precision)     Wavelet's method (default: 8).</p>"},{"location":"ref/#pywt.central_frequency--returns","title":"Returns","text":"<p>scalar</p> Source code in <code>pywt/_functions.py</code> <pre><code>def central_frequency(wavelet, precision=8):\n    \"\"\"\n    Computes the central frequency of the `psi` wavelet function.\n\n    Parameters\n    ----------\n    wavelet : Wavelet instance, str or tuple\n        Wavelet to integrate.  If a string, should be the name of a wavelet.\n    precision : int, optional\n        Precision that will be used for wavelet function\n        approximation computed with the wavefun(level=precision)\n        Wavelet's method (default: 8).\n\n    Returns\n    -------\n    scalar\n\n    \"\"\"\n\n    if not isinstance(wavelet, (Wavelet, ContinuousWavelet)):\n        wavelet = DiscreteContinuousWavelet(wavelet)\n\n    functions_approximations = wavelet.wavefun(precision)\n\n    if len(functions_approximations) == 2:\n        psi, x = functions_approximations\n    else:\n        # (psi, x)   for (phi, psi, x)\n        # (psi_d, x) for (phi_d, psi_d, phi_r, psi_r, x)\n        psi, x = functions_approximations[1], functions_approximations[-1]\n\n    domain = float(x[-1] - x[0])\n    assert domain &gt; 0\n\n    index = np.argmax(abs(fft(psi)[1:])) + 2\n    if index &gt; len(psi) / 2:\n        index = len(psi) - index + 2\n\n    return 1.0 / (domain / (index - 1))\n</code></pre>"},{"location":"ref/#pywt.coeffs_to_array","title":"<code>coeffs_to_array(coeffs, padding=0, axes=None)</code>","text":"<p>Arrange a wavelet coefficient list from <code>wavedecn</code> into a single array.</p>"},{"location":"ref/#pywt.coeffs_to_array--parameters","title":"Parameters","text":"array-like <p>Dictionary of wavelet coefficients as returned by pywt.wavedecn</p> <p>padding : float or None, optional     The value to use for the background if the coefficients cannot be     tightly packed. If None, raise an error if the coefficients cannot be     tightly packed. axes : sequence of ints, optional     Axes over which the DWT that created <code>coeffs</code> was performed.  The     default value of None corresponds to all axes.</p>"},{"location":"ref/#pywt.coeffs_to_array--returns","title":"Returns","text":"<p>coeff_arr : array-like     Wavelet transform coefficient array. coeff_slices : list     List of slices corresponding to each coefficient.  As a 2D example,     <code>coeff_arr[coeff_slices[1]['dd']]</code> would extract the first level     detail coefficients from <code>coeff_arr</code>.</p>"},{"location":"ref/#pywt.coeffs_to_array--see-also","title":"See Also","text":"<p>array_to_coeffs : the inverse of coeffs_to_array</p>"},{"location":"ref/#pywt.coeffs_to_array--notes","title":"Notes","text":"<p>Assume a 2D coefficient dictionary, c, from a two-level transform.</p> <p>Then all 2D coefficients will be stacked into a single larger 2D array as follows::</p> <pre><code>+---------------+---------------+-------------------------------+\n|               |               |                               |\n|     c[0]      |  c[1]['da']   |                               |\n|               |               |                               |\n+---------------+---------------+           c[2]['da']          |\n|               |               |                               |\n| c[1]['ad']    |  c[1]['dd']   |                               |\n|               |               |                               |\n+---------------+---------------+ ------------------------------+\n|                               |                               |\n|                               |                               |\n|                               |                               |\n|          c[2]['ad']           |           c[2]['dd']          |\n|                               |                               |\n|                               |                               |\n|                               |                               |\n+-------------------------------+-------------------------------+\n</code></pre> <p>If the transform was not performed with mode \"periodization\" or the signal length was not a multiple of <code>2**level</code>, coefficients at each subsequent scale will not be exactly 1/2 the size of those at the previous level due to additional coefficients retained to handle the boundary condition. In these cases, the default setting of <code>padding=0</code> indicates to pad the individual coefficient arrays with 0 as needed so that they can be stacked into a single, contiguous array.</p>"},{"location":"ref/#pywt.coeffs_to_array--examples","title":"Examples","text":"<p>import pywt cam = pywt.data.camera() coeffs = pywt.wavedecn(cam, wavelet='db2', level=3) arr, coeff_slices = pywt.coeffs_to_array(coeffs)</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def coeffs_to_array(coeffs, padding=0, axes=None):\n    \"\"\"\n    Arrange a wavelet coefficient list from ``wavedecn`` into a single array.\n\n    Parameters\n    ----------\n\n    coeffs : array-like\n        Dictionary of wavelet coefficients as returned by pywt.wavedecn\n    padding : float or None, optional\n        The value to use for the background if the coefficients cannot be\n        tightly packed. If None, raise an error if the coefficients cannot be\n        tightly packed.\n    axes : sequence of ints, optional\n        Axes over which the DWT that created ``coeffs`` was performed.  The\n        default value of None corresponds to all axes.\n\n    Returns\n    -------\n    coeff_arr : array-like\n        Wavelet transform coefficient array.\n    coeff_slices : list\n        List of slices corresponding to each coefficient.  As a 2D example,\n        ``coeff_arr[coeff_slices[1]['dd']]`` would extract the first level\n        detail coefficients from ``coeff_arr``.\n\n    See Also\n    --------\n    array_to_coeffs : the inverse of coeffs_to_array\n\n    Notes\n    -----\n    Assume a 2D coefficient dictionary, c, from a two-level transform.\n\n    Then all 2D coefficients will be stacked into a single larger 2D array\n    as follows::\n\n        +---------------+---------------+-------------------------------+\n        |               |               |                               |\n        |     c[0]      |  c[1]['da']   |                               |\n        |               |               |                               |\n        +---------------+---------------+           c[2]['da']          |\n        |               |               |                               |\n        | c[1]['ad']    |  c[1]['dd']   |                               |\n        |               |               |                               |\n        +---------------+---------------+ ------------------------------+\n        |                               |                               |\n        |                               |                               |\n        |                               |                               |\n        |          c[2]['ad']           |           c[2]['dd']          |\n        |                               |                               |\n        |                               |                               |\n        |                               |                               |\n        +-------------------------------+-------------------------------+\n\n    If the transform was not performed with mode \"periodization\" or the signal\n    length was not a multiple of ``2**level``, coefficients at each subsequent\n    scale will not be exactly 1/2 the size of those at the previous level due\n    to additional coefficients retained to handle the boundary condition. In\n    these cases, the default setting of `padding=0` indicates to pad the\n    individual coefficient arrays with 0 as needed so that they can be stacked\n    into a single, contiguous array.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; cam = pywt.data.camera()\n    &gt;&gt;&gt; coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n    &gt;&gt;&gt; arr, coeff_slices = pywt.coeffs_to_array(coeffs)\n\n    \"\"\"\n\n    coeffs, axes, ndim, ndim_transform = _prepare_coeffs_axes(coeffs, axes)\n\n    # initialize with the approximation coefficients.\n    a_coeffs = coeffs[0]\n    a_shape = a_coeffs.shape\n\n    if len(coeffs) == 1:\n        # only a single approximation coefficient array was found\n        return a_coeffs, [tuple([slice(None)] * ndim)]\n\n    # determine size of output and if tight packing is possible\n    arr_shape, is_tight_packing = _determine_coeff_array_shape(coeffs, axes)\n\n    # preallocate output array\n    if padding is None:\n        if not is_tight_packing:\n            raise ValueError(\"array coefficients cannot be tightly packed\")\n        coeff_arr = np.empty(arr_shape, dtype=a_coeffs.dtype)\n    else:\n        coeff_arr = np.full(arr_shape, padding, dtype=a_coeffs.dtype)\n\n    a_slices = tuple([slice(s) for s in a_shape])\n    coeff_arr[a_slices] = a_coeffs\n\n    # initialize list of coefficient slices\n    coeff_slices = []\n    coeff_slices.append(a_slices)\n\n    # loop over the detail coefficients, adding them to coeff_arr\n    ds = coeffs[1:]\n    for coeff_dict in ds:\n        coeff_slices.append({})  # new dictionary for detail coefficients\n        if np.any([d is None for d in coeff_dict.values()]):\n            raise ValueError(\"coeffs_to_array does not support missing \"\n                             \"coefficients.\")\n        d_shape = coeff_dict['d' * ndim_transform].shape\n        for key in coeff_dict:\n            d = coeff_dict[key]\n            slice_array = [slice(None), ] * ndim\n            for i, let in enumerate(key):\n                ax_i = axes[i]  # axis corresponding to this transform index\n                if let == 'a':\n                    slice_array[ax_i] = slice(d.shape[ax_i])\n                elif let == 'd':\n                    slice_array[ax_i] = slice(a_shape[ax_i],\n                                              a_shape[ax_i] + d.shape[ax_i])\n                else:\n                    raise ValueError(f\"unexpected letter: {let}\")\n            slice_array = tuple(slice_array)\n            coeff_arr[slice_array] = d\n            coeff_slices[-1][key] = slice_array\n        a_shape = [a_shape[n] + d_shape[n] for n in range(ndim)]\n    return coeff_arr, coeff_slices\n</code></pre>"},{"location":"ref/#pywt.cwt","title":"<code>cwt(data, scales, wavelet, sampling_period=1.0, method='conv', axis=-1)</code>","text":"<p>cwt(data, scales, wavelet)</p> <p>One dimensional Continuous Wavelet Transform.</p>"},{"location":"ref/#pywt.cwt--parameters","title":"Parameters","text":"<p>data : array_like     Input signal scales : array_like     The wavelet scales to use. One can use     <code>f = scale2frequency(wavelet, scale)/sampling_period</code> to determine     what physical frequency, <code>f</code>. Here, <code>f</code> is in hertz when the     <code>sampling_period</code> is given in seconds. wavelet : Wavelet object or name     Wavelet to use sampling_period : float     Sampling period for the frequencies output (optional).     The values computed for <code>coefs</code> are independent of the choice of     <code>sampling_period</code> (i.e. <code>scales</code> is not scaled by the sampling     period). method : {'conv', 'fft'}, optional     The method used to compute the CWT. Can be any of:         - <code>conv</code> uses <code>numpy.convolve</code>.         - <code>fft</code> uses frequency domain convolution.         - <code>auto</code> uses automatic selection based on an estimate of the           computational complexity at each scale.</p> <pre><code>The ``conv`` method complexity is ``O(len(scale) * len(data))``.\nThe ``fft`` method is ``O(N * log2(N))`` with\n``N = len(scale) + len(data) - 1``. It is well suited for large size\nsignals but slightly slower than ``conv`` on small ones.\n</code></pre> <p>axis: int, optional     Axis over which to compute the CWT. If not given, the last axis is     used.</p>"},{"location":"ref/#pywt.cwt--returns","title":"Returns","text":"<p>coefs : array_like     Continuous wavelet transform of the input signal for the given scales     and wavelet. The first axis of <code>coefs</code> corresponds to the scales.     The remaining axes match the shape of <code>data</code>. frequencies : array_like     If the unit of sampling period are seconds and given, then frequencies     are in hertz. Otherwise, a sampling period of 1 is assumed.</p>"},{"location":"ref/#pywt.cwt--notes","title":"Notes","text":"<p>Size of coefficients arrays depends on the length of the input array and the length of given scales.</p>"},{"location":"ref/#pywt.cwt--examples","title":"Examples","text":"<p>import pywt import numpy as np import matplotlib.pyplot as plt x = np.arange(512) y = np.sin(2np.pix/32) coef, freqs=pywt.cwt(y,np.arange(1,129),'gaus1') plt.matshow(coef) plt.show()</p> <p>import pywt import numpy as np import matplotlib.pyplot as plt t = np.linspace(-1, 1, 200, endpoint=False) sig  = np.cos(2 * np.pi * 7 * t) + np.real(np.exp(-7(t-0.4)2)np.exp(1j2np.pi2(t-0.4))) widths = np.arange(1, 31) cwtmatr, freqs = pywt.cwt(sig, widths, 'mexh') plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto', ...            vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max()) plt.show()</p> Source code in <code>pywt/_cwt.py</code> <pre><code>def cwt(data, scales, wavelet, sampling_period=1., method='conv', axis=-1):\n    \"\"\"\n    cwt(data, scales, wavelet)\n\n    One dimensional Continuous Wavelet Transform.\n\n    Parameters\n    ----------\n    data : array_like\n        Input signal\n    scales : array_like\n        The wavelet scales to use. One can use\n        ``f = scale2frequency(wavelet, scale)/sampling_period`` to determine\n        what physical frequency, ``f``. Here, ``f`` is in hertz when the\n        ``sampling_period`` is given in seconds.\n    wavelet : Wavelet object or name\n        Wavelet to use\n    sampling_period : float\n        Sampling period for the frequencies output (optional).\n        The values computed for ``coefs`` are independent of the choice of\n        ``sampling_period`` (i.e. ``scales`` is not scaled by the sampling\n        period).\n    method : {'conv', 'fft'}, optional\n        The method used to compute the CWT. Can be any of:\n            - ``conv`` uses ``numpy.convolve``.\n            - ``fft`` uses frequency domain convolution.\n            - ``auto`` uses automatic selection based on an estimate of the\n              computational complexity at each scale.\n\n        The ``conv`` method complexity is ``O(len(scale) * len(data))``.\n        The ``fft`` method is ``O(N * log2(N))`` with\n        ``N = len(scale) + len(data) - 1``. It is well suited for large size\n        signals but slightly slower than ``conv`` on small ones.\n    axis: int, optional\n        Axis over which to compute the CWT. If not given, the last axis is\n        used.\n\n    Returns\n    -------\n    coefs : array_like\n        Continuous wavelet transform of the input signal for the given scales\n        and wavelet. The first axis of ``coefs`` corresponds to the scales.\n        The remaining axes match the shape of ``data``.\n    frequencies : array_like\n        If the unit of sampling period are seconds and given, then frequencies\n        are in hertz. Otherwise, a sampling period of 1 is assumed.\n\n    Notes\n    -----\n    Size of coefficients arrays depends on the length of the input array and\n    the length of given scales.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; x = np.arange(512)\n    &gt;&gt;&gt; y = np.sin(2*np.pi*x/32)\n    &gt;&gt;&gt; coef, freqs=pywt.cwt(y,np.arange(1,129),'gaus1')\n    &gt;&gt;&gt; plt.matshow(coef)\n    &gt;&gt;&gt; plt.show()\n\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; t = np.linspace(-1, 1, 200, endpoint=False)\n    &gt;&gt;&gt; sig  = np.cos(2 * np.pi * 7 * t) + np.real(np.exp(-7*(t-0.4)**2)*np.exp(1j*2*np.pi*2*(t-0.4)))\n    &gt;&gt;&gt; widths = np.arange(1, 31)\n    &gt;&gt;&gt; cwtmatr, freqs = pywt.cwt(sig, widths, 'mexh')\n    &gt;&gt;&gt; plt.imshow(cwtmatr, extent=[-1, 1, 1, 31], cmap='PRGn', aspect='auto',\n    ...            vmax=abs(cwtmatr).max(), vmin=-abs(cwtmatr).max())\n    &gt;&gt;&gt; plt.show()\n    \"\"\"\n\n    # accept array_like input; make a copy to ensure a contiguous array\n    dt = _check_dtype(data)\n    data = np.asarray(data, dtype=dt)\n    dt_cplx = np.result_type(dt, np.complex64)\n    if not isinstance(wavelet, (ContinuousWavelet, Wavelet)):\n        wavelet = DiscreteContinuousWavelet(wavelet)\n\n    scales = np.atleast_1d(scales)\n    if np.any(scales &lt;= 0):\n        raise ValueError(\"`scales` must only include positive values\")\n\n    if not np.isscalar(axis):\n        raise AxisError(\"axis must be a scalar.\")\n\n    dt_out = dt_cplx if wavelet.complex_cwt else dt\n    out = np.empty((np.size(scales),) + data.shape, dtype=dt_out)\n    precision = 10\n    int_psi, x = integrate_wavelet(wavelet, precision=precision)\n    int_psi = np.conj(int_psi) if wavelet.complex_cwt else int_psi\n\n    # convert int_psi, x to the same precision as the data\n    dt_psi = dt_cplx if int_psi.dtype.kind == 'c' else dt\n    int_psi = np.asarray(int_psi, dtype=dt_psi)\n    x = np.asarray(x, dtype=data.real.dtype)\n\n    if method == 'fft':\n        size_scale0 = -1\n        fft_data = None\n    elif method != \"conv\":\n        raise ValueError(\"method must be 'conv' or 'fft'\")\n\n    if data.ndim &gt; 1:\n        # move axis to be transformed last (so it is contiguous)\n        data = data.swapaxes(-1, axis)\n\n        # reshape to (n_batch, data.shape[-1])\n        data_shape_pre = data.shape\n        data = data.reshape((-1, data.shape[-1]))\n\n    for i, scale in enumerate(scales):\n        step = x[1] - x[0]\n        j = np.arange(scale * (x[-1] - x[0]) + 1) / (scale * step)\n        j = j.astype(int)  # floor\n        if j[-1] &gt;= int_psi.size:\n            j = np.extract(j &lt; int_psi.size, j)\n        int_psi_scale = int_psi[j][::-1]\n\n        if method == 'conv':\n            if data.ndim == 1:\n                conv = np.convolve(data, int_psi_scale)\n            else:\n                # batch convolution via loop\n                conv_shape = list(data.shape)\n                conv_shape[-1] += int_psi_scale.size - 1\n                conv_shape = tuple(conv_shape)\n                conv = np.empty(conv_shape, dtype=dt_out)\n                for n in range(data.shape[0]):\n                    conv[n, :] = np.convolve(data[n], int_psi_scale)\n        else:\n            # The padding is selected for:\n            # - optimal FFT complexity\n            # - to be larger than the two signals length to avoid circular\n            #   convolution\n            size_scale = next_fast_len(\n                data.shape[-1] + int_psi_scale.size - 1\n            )\n            if size_scale != size_scale0:\n                # Must recompute fft_data when the padding size changes.\n                fft_data = fftmodule.fft(data, size_scale, axis=-1)\n            size_scale0 = size_scale\n            fft_wav = fftmodule.fft(int_psi_scale, size_scale, axis=-1)\n            conv = fftmodule.ifft(fft_wav * fft_data, axis=-1)\n            conv = conv[..., :data.shape[-1] + int_psi_scale.size - 1]\n\n        coef = - np.sqrt(scale) * np.diff(conv, axis=-1)\n        if out.dtype.kind != 'c':\n            coef = coef.real\n        # transform axis is always -1 due to the data reshape above\n        d = (coef.shape[-1] - data.shape[-1]) / 2.\n        if d &gt; 0:\n            coef = coef[..., floor(d):-ceil(d)]\n        elif d &lt; 0:\n            raise ValueError(\n                f\"Selected scale of {scale} too small.\")\n        if data.ndim &gt; 1:\n            # restore original data shape and axis position\n            coef = coef.reshape(data_shape_pre)\n            coef = coef.swapaxes(axis, -1)\n        out[i, ...] = coef\n\n    frequencies = scale2frequency(wavelet, scales, precision)\n    if np.isscalar(frequencies):\n        frequencies = np.array([frequencies])\n    frequencies /= sampling_period\n    return out, frequencies\n</code></pre>"},{"location":"ref/#pywt.downcoef","title":"<code>downcoef(part, data, wavelet, mode='symmetric', level=1)</code>","text":"<p>downcoef(part, data, wavelet, mode='symmetric', level=1)</p> <p>Partial Discrete Wavelet Transform data decomposition.</p> <p>Similar to <code>pywt.dwt</code>, but computes only one set of coefficients. Useful when you need only approximation or only details at the given level.</p>"},{"location":"ref/#pywt.downcoef--parameters","title":"Parameters","text":"<p>part : str     Coefficients type:</p> <pre><code>* 'a' - approximations reconstruction is performed\n* 'd' - details reconstruction is performed\n</code></pre> array_like <p>Input signal.</p> <p>wavelet : Wavelet object or name     Wavelet to use mode : str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. level : int, optional     Decomposition level.  Default is 1.</p>"},{"location":"ref/#pywt.downcoef--returns","title":"Returns","text":"<p>coeffs : ndarray     1-D array of coefficients.</p>"},{"location":"ref/#pywt.downcoef--see-also","title":"See Also","text":"<p>upcoef</p> Source code in <code>pywt/_dwt.py</code> <pre><code>def downcoef(part, data, wavelet, mode='symmetric', level=1):\n    \"\"\"\n    downcoef(part, data, wavelet, mode='symmetric', level=1)\n\n    Partial Discrete Wavelet Transform data decomposition.\n\n    Similar to ``pywt.dwt``, but computes only one set of coefficients.\n    Useful when you need only approximation or only details at the given level.\n\n    Parameters\n    ----------\n    part : str\n        Coefficients type:\n\n        * 'a' - approximations reconstruction is performed\n        * 'd' - details reconstruction is performed\n\n    data : array_like\n        Input signal.\n    wavelet : Wavelet object or name\n        Wavelet to use\n    mode : str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n    level : int, optional\n        Decomposition level.  Default is 1.\n\n    Returns\n    -------\n    coeffs : ndarray\n        1-D array of coefficients.\n\n    See Also\n    --------\n    upcoef\n\n    \"\"\"\n    if not _have_c99_complex and np.iscomplexobj(data):\n        return (downcoef(part, data.real, wavelet, mode, level) +\n                1j*downcoef(part, data.imag, wavelet, mode, level))\n    # accept array_like input; make a copy to ensure a contiguous array\n    dt = _check_dtype(data)\n    data = np.asarray(data, dtype=dt, order='C')\n    if data.ndim &gt; 1:\n        raise ValueError(\"downcoef only supports 1d data.\")\n    if part not in 'ad':\n        raise ValueError(f\"Argument 1 must be 'a' or 'd', not '{part}'.\")\n    mode = Modes.from_object(mode)\n    wavelet = _as_wavelet(wavelet)\n    return np.asarray(_downcoef(part == 'a', data, wavelet, mode, level))\n</code></pre>"},{"location":"ref/#pywt.dwt","title":"<code>dwt(data, wavelet, mode='symmetric', axis=-1)</code>","text":"<p>dwt(data, wavelet, mode='symmetric', axis=-1)</p> <p>Single level Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.dwt--parameters","title":"Parameters","text":"<p>data : array_like     Input signal wavelet : Wavelet object or name     Wavelet to use mode : str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. axis: int, optional     Axis over which to compute the DWT. If not given, the     last axis is used.</p>"},{"location":"ref/#pywt.dwt--returns","title":"Returns","text":"<p>(cA, cD) : tuple     Approximation and detail coefficients.</p>"},{"location":"ref/#pywt.dwt--notes","title":"Notes","text":"<p>Length of coefficients arrays depends on the selected mode. For all modes except periodization:</p> <pre><code>``len(cA) == len(cD) == floor((len(data) + wavelet.dec_len - 1) / 2)``\n</code></pre> <p>For periodization mode (\"per\"):</p> <pre><code>``len(cA) == len(cD) == ceil(len(data) / 2)``\n</code></pre>"},{"location":"ref/#pywt.dwt--examples","title":"Examples","text":"<p>import pywt (cA, cD) = pywt.dwt([1, 2, 3, 4, 5, 6], 'db1') cA array([ 2.12132034,  4.94974747,  7.77817459]) cD array([-0.70710678, -0.70710678, -0.70710678])</p> Source code in <code>pywt/_dwt.py</code> <pre><code>def dwt(data, wavelet, mode='symmetric', axis=-1):\n    \"\"\"\n    dwt(data, wavelet, mode='symmetric', axis=-1)\n\n    Single level Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    data : array_like\n        Input signal\n    wavelet : Wavelet object or name\n        Wavelet to use\n    mode : str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n    axis: int, optional\n        Axis over which to compute the DWT. If not given, the\n        last axis is used.\n\n    Returns\n    -------\n    (cA, cD) : tuple\n        Approximation and detail coefficients.\n\n    Notes\n    -----\n    Length of coefficients arrays depends on the selected mode.\n    For all modes except periodization:\n\n        ``len(cA) == len(cD) == floor((len(data) + wavelet.dec_len - 1) / 2)``\n\n    For periodization mode (\"per\"):\n\n        ``len(cA) == len(cD) == ceil(len(data) / 2)``\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; (cA, cD) = pywt.dwt([1, 2, 3, 4, 5, 6], 'db1')\n    &gt;&gt;&gt; cA\n    array([ 2.12132034,  4.94974747,  7.77817459])\n    &gt;&gt;&gt; cD\n    array([-0.70710678, -0.70710678, -0.70710678])\n\n    \"\"\"\n    if not _have_c99_complex and np.iscomplexobj(data):\n        data = np.asarray(data)\n        cA_r, cD_r = dwt(data.real, wavelet, mode, axis)\n        cA_i, cD_i = dwt(data.imag, wavelet, mode, axis)\n        return (cA_r + 1j*cA_i, cD_r + 1j*cD_i)\n\n    # accept array_like input; make a copy to ensure a contiguous array\n    dt = _check_dtype(data)\n    data = np.asarray(data, dtype=dt, order='C')\n    mode = Modes.from_object(mode)\n    wavelet = _as_wavelet(wavelet)\n\n    if axis &lt; 0:\n        axis = axis + data.ndim\n    if not 0 &lt;= axis &lt; data.ndim:\n        raise AxisError(\"Axis greater than data dimensions\")\n\n    if data.ndim == 1:\n        cA, cD = dwt_single(data, wavelet, mode)\n        # TODO: Check whether this makes a copy\n        cA, cD = np.asarray(cA, dt), np.asarray(cD, dt)\n    else:\n        cA, cD = dwt_axis(data, wavelet, mode, axis=axis)\n\n    return (cA, cD)\n</code></pre>"},{"location":"ref/#pywt.dwt2","title":"<code>dwt2(data, wavelet, mode='symmetric', axes=(-2, -1))</code>","text":"<p>2D Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.dwt2--parameters","title":"Parameters","text":"<p>data : array_like     2D array with input data wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or 2-tuple of strings, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple of modes specifying the mode to use on each axis in     <code>axes</code>. axes : 2-tuple of ints, optional     Axes over which to compute the DWT. Repeated elements mean the DWT will     be performed multiple times along these axes.</p>"},{"location":"ref/#pywt.dwt2--returns","title":"Returns","text":"<p>(cA, (cH, cV, cD)) : tuple     Approximation, horizontal detail, vertical detail and diagonal     detail coefficients respectively.  Horizontal refers to array axis 0     (or <code>axes[0]</code> for user-specified <code>axes</code>).</p>"},{"location":"ref/#pywt.dwt2--examples","title":"Examples","text":"<p>import numpy as np import pywt data = np.ones((4,4), dtype=np.float64) coeffs = pywt.dwt2(data, 'haar') cA, (cH, cV, cD) = coeffs cA array([[ 2.,  2.],        [ 2.,  2.]]) cV array([[ 0.,  0.],        [ 0.,  0.]])</p> Source code in <code>pywt/_multidim.py</code> <pre><code>def dwt2(data, wavelet, mode='symmetric', axes=(-2, -1)):\n    \"\"\"\n    2D Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    data : array_like\n        2D array with input data\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or 2-tuple of strings, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple of modes specifying the mode to use on each axis in\n        ``axes``.\n    axes : 2-tuple of ints, optional\n        Axes over which to compute the DWT. Repeated elements mean the DWT will\n        be performed multiple times along these axes.\n\n    Returns\n    -------\n    (cA, (cH, cV, cD)) : tuple\n        Approximation, horizontal detail, vertical detail and diagonal\n        detail coefficients respectively.  Horizontal refers to array axis 0\n        (or ``axes[0]`` for user-specified ``axes``).\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; data = np.ones((4,4), dtype=np.float64)\n    &gt;&gt;&gt; coeffs = pywt.dwt2(data, 'haar')\n    &gt;&gt;&gt; cA, (cH, cV, cD) = coeffs\n    &gt;&gt;&gt; cA\n    array([[ 2.,  2.],\n           [ 2.,  2.]])\n    &gt;&gt;&gt; cV\n    array([[ 0.,  0.],\n           [ 0.,  0.]])\n\n    \"\"\"\n    axes = tuple(axes)\n    data = np.asarray(data)\n    if len(axes) != 2:\n        raise ValueError(\"Expected 2 axes\")\n    if data.ndim &lt; len(np.unique(axes)):\n        raise ValueError(\"Input array has fewer dimensions than the specified \"\n                         \"axes\")\n\n    coefs = dwtn(data, wavelet, mode, axes)\n    return coefs['aa'], (coefs['da'], coefs['ad'], coefs['dd'])\n</code></pre>"},{"location":"ref/#pywt.dwt_coeff_len","title":"<code>dwt_coeff_len(data_len, filter_len, mode)</code>","text":"<p>dwt_coeff_len(data_len, filter_len, mode='symmetric')</p> <p>Returns length of dwt output for given data length, filter length and mode</p>"},{"location":"ref/#pywt.dwt_coeff_len--parameters","title":"Parameters","text":"<p>data_len : int     Data length. filter_len : int     Filter length. mode : str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>.</p>"},{"location":"ref/#pywt.dwt_coeff_len--returns","title":"Returns","text":"<p>len : int     Length of dwt output.</p>"},{"location":"ref/#pywt.dwt_coeff_len--notes","title":"Notes","text":"<p>For all modes except periodization::</p> <pre><code>len(cA) == len(cD) == floor((len(data) + wavelet.dec_len - 1) / 2)\n</code></pre> <p>for periodization mode (\"per\")::</p> <pre><code>len(cA) == len(cD) == ceil(len(data) / 2)\n</code></pre> Source code in <code>pywt/_dwt.py</code> <pre><code>def dwt_coeff_len(data_len, filter_len, mode):\n    \"\"\"\n    dwt_coeff_len(data_len, filter_len, mode='symmetric')\n\n    Returns length of dwt output for given data length, filter length and mode\n\n    Parameters\n    ----------\n    data_len : int\n        Data length.\n    filter_len : int\n        Filter length.\n    mode : str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n\n    Returns\n    -------\n    len : int\n        Length of dwt output.\n\n    Notes\n    -----\n    For all modes except periodization::\n\n        len(cA) == len(cD) == floor((len(data) + wavelet.dec_len - 1) / 2)\n\n    for periodization mode (\"per\")::\n\n        len(cA) == len(cD) == ceil(len(data) / 2)\n\n    \"\"\"\n    if isinstance(filter_len, Wavelet):\n        filter_len = filter_len.dec_len\n\n    return _dwt_coeff_len(data_len, filter_len, Modes.from_object(mode))\n</code></pre>"},{"location":"ref/#pywt.dwt_max_level","title":"<code>dwt_max_level(data_len, filter_len)</code>","text":"<p>dwt_max_level(data_len, filter_len)</p> <p>Compute the maximum useful level of decomposition.</p>"},{"location":"ref/#pywt.dwt_max_level--parameters","title":"Parameters","text":"<p>data_len : int     Input data length. filter_len : int, str or Wavelet     The wavelet filter length.  Alternatively, the name of a discrete     wavelet or a Wavelet object can be specified.</p>"},{"location":"ref/#pywt.dwt_max_level--returns","title":"Returns","text":"<p>max_level : int     Maximum level.</p>"},{"location":"ref/#pywt.dwt_max_level--notes","title":"Notes","text":"<p>The rational for the choice of levels is the maximum level where at least one coefficient in the output is uncorrupted by edge effects caused by signal extension.  Put another way, decomposition stops when the signal becomes shorter than the FIR filter length for a given wavelet.  This corresponds to:</p> <p>.. max_level = floor(log2(data_len/(filter_len - 1)))</p> <p>.. math::     \\mathtt{max_level} = \\left\\lfloor\\log_2\\left(\\mathtt{         \\frac{data_len}{filter_len - 1}}\\right)\\right\\rfloor</p>"},{"location":"ref/#pywt.dwt_max_level--examples","title":"Examples","text":"<p>import pywt w = pywt.Wavelet('sym5') pywt.dwt_max_level(data_len=1000, filter_len=w.dec_len) 6 pywt.dwt_max_level(1000, w) 6 pywt.dwt_max_level(1000, 'sym5') 6</p> Source code in <code>pywt/_dwt.py</code> <pre><code>def dwt_max_level(data_len, filter_len):\n    r\"\"\"\n    dwt_max_level(data_len, filter_len)\n\n    Compute the maximum useful level of decomposition.\n\n    Parameters\n    ----------\n    data_len : int\n        Input data length.\n    filter_len : int, str or Wavelet\n        The wavelet filter length.  Alternatively, the name of a discrete\n        wavelet or a Wavelet object can be specified.\n\n    Returns\n    -------\n    max_level : int\n        Maximum level.\n\n    Notes\n    -----\n    The rational for the choice of levels is the maximum level where at least\n    one coefficient in the output is uncorrupted by edge effects caused by\n    signal extension.  Put another way, decomposition stops when the signal\n    becomes shorter than the FIR filter length for a given wavelet.  This\n    corresponds to:\n\n    .. max_level = floor(log2(data_len/(filter_len - 1)))\n\n    .. math::\n        \\mathtt{max\\_level} = \\left\\lfloor\\log_2\\left(\\mathtt{\n            \\frac{data\\_len}{filter\\_len - 1}}\\right)\\right\\rfloor\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; w = pywt.Wavelet('sym5')\n    &gt;&gt;&gt; pywt.dwt_max_level(data_len=1000, filter_len=w.dec_len)\n    6\n    &gt;&gt;&gt; pywt.dwt_max_level(1000, w)\n    6\n    &gt;&gt;&gt; pywt.dwt_max_level(1000, 'sym5')\n    6\n    \"\"\"\n    if isinstance(filter_len, Wavelet):\n        filter_len = filter_len.dec_len\n    elif isinstance(filter_len, str):\n        if filter_len in wavelist(kind='discrete'):\n            filter_len = Wavelet(filter_len).dec_len\n        else:\n            raise ValueError(\n                f\"'{filter_len}', is not a recognized discrete wavelet.  A list of \"\n                 \"supported wavelet names can be obtained via \"\n                 \"pywt.wavelist(kind='discrete')\")\n    elif not (isinstance(filter_len, Number) and filter_len % 1 == 0):\n        raise ValueError(\n            \"filter_len must be an integer, discrete Wavelet object, or the \"\n            \"name of a discrete wavelet.\")\n\n    if filter_len &lt; 2:\n        raise ValueError(\"invalid wavelet filter length\")\n\n    return _dwt_max_level(data_len, filter_len)\n</code></pre>"},{"location":"ref/#pywt.dwtn","title":"<code>dwtn(data, wavelet, mode='symmetric', axes=None)</code>","text":"<p>Single-level n-dimensional Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.dwtn--parameters","title":"Parameters","text":"<p>data : array_like     n-dimensional array with input data. wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or tuple of string, optional     Signal extension mode used in the decomposition,     see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can also be a tuple of modes     specifying the mode to use on each axis in <code>axes</code>. axes : sequence of ints, optional     Axes over which to compute the DWT. Repeated elements mean the DWT will     be performed multiple times along these axes. A value of <code>None</code> (the     default) selects all axes.</p> <pre><code>Axes may be repeated, but information about the original size may be\nlost if it is not divisible by ``2 ** nrepeats``. The reconstruction\nwill be larger, with additional values derived according to the\n``mode`` parameter. ``pywt.wavedecn`` should be used for multilevel\ndecomposition.\n</code></pre>"},{"location":"ref/#pywt.dwtn--returns","title":"Returns","text":"<p>coeffs : dict     Results are arranged in a dictionary, where key specifies     the transform type on each dimension and value is a n-dimensional     coefficients array.</p> <pre><code>For example, for a 2D case the result will look something like this::\n\n    {'aa': &lt;coeffs&gt;  # A(LL) - approx. on 1st dim, approx. on 2nd dim\n     'ad': &lt;coeffs&gt;  # V(LH) - approx. on 1st dim, det. on 2nd dim\n     'da': &lt;coeffs&gt;  # H(HL) - det. on 1st dim, approx. on 2nd dim\n     'dd': &lt;coeffs&gt;  # D(HH) - det. on 1st dim, det. on 2nd dim\n    }\n\nFor user-specified ``axes``, the order of the characters in the\ndictionary keys map to the specified ``axes``.\n</code></pre> Source code in <code>pywt/_multidim.py</code> <pre><code>def dwtn(data, wavelet, mode='symmetric', axes=None):\n    \"\"\"\n    Single-level n-dimensional Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    data : array_like\n        n-dimensional array with input data.\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or tuple of string, optional\n        Signal extension mode used in the decomposition,\n        see :ref:`Modes &lt;ref-modes&gt;`. This can also be a tuple of modes\n        specifying the mode to use on each axis in ``axes``.\n    axes : sequence of ints, optional\n        Axes over which to compute the DWT. Repeated elements mean the DWT will\n        be performed multiple times along these axes. A value of ``None`` (the\n        default) selects all axes.\n\n        Axes may be repeated, but information about the original size may be\n        lost if it is not divisible by ``2 ** nrepeats``. The reconstruction\n        will be larger, with additional values derived according to the\n        ``mode`` parameter. ``pywt.wavedecn`` should be used for multilevel\n        decomposition.\n\n    Returns\n    -------\n    coeffs : dict\n        Results are arranged in a dictionary, where key specifies\n        the transform type on each dimension and value is a n-dimensional\n        coefficients array.\n\n        For example, for a 2D case the result will look something like this::\n\n            {'aa': &lt;coeffs&gt;  # A(LL) - approx. on 1st dim, approx. on 2nd dim\n             'ad': &lt;coeffs&gt;  # V(LH) - approx. on 1st dim, det. on 2nd dim\n             'da': &lt;coeffs&gt;  # H(HL) - det. on 1st dim, approx. on 2nd dim\n             'dd': &lt;coeffs&gt;  # D(HH) - det. on 1st dim, det. on 2nd dim\n            }\n\n        For user-specified ``axes``, the order of the characters in the\n        dictionary keys map to the specified ``axes``.\n\n    \"\"\"\n    data = np.asarray(data)\n    if not _have_c99_complex and np.iscomplexobj(data):\n        real = dwtn(data.real, wavelet, mode, axes)\n        imag = dwtn(data.imag, wavelet, mode, axes)\n        return {k: real[k] + 1j * imag[k] for k in real}\n\n    if data.dtype == np.dtype('object'):\n        raise TypeError(\"Input must be a numeric array-like\")\n    if data.ndim &lt; 1:\n        raise ValueError(\"Input data must be at least 1D\")\n\n    if axes is None:\n        axes = range(data.ndim)\n    axes = [a + data.ndim if a &lt; 0 else a for a in axes]\n\n    modes = _modes_per_axis(mode, axes)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n\n    coeffs = [('', data)]\n    for axis, wav, mode in zip(axes, wavelets, modes):\n        new_coeffs = []\n        for subband, x in coeffs:\n            cA, cD = dwt_axis(x, wav, mode, axis)\n            new_coeffs.extend([(subband + 'a', cA),\n                               (subband + 'd', cD)])\n        coeffs = new_coeffs\n    return dict(coeffs)\n</code></pre>"},{"location":"ref/#pywt.dwtn_max_level","title":"<code>dwtn_max_level(shape, wavelet, axes=None)</code>","text":"<p>Compute the maximum level of decomposition for n-dimensional data.</p> <p>This returns the maximum number of levels of decomposition suitable for use with <code>wavedec</code>, <code>wavedec2</code> or <code>wavedecn</code>.</p>"},{"location":"ref/#pywt.dwtn_max_level--parameters","title":"Parameters","text":"<p>shape : sequence of ints     Input data shape. wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use. This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. axes : sequence of ints, optional     Axes over which to compute the DWT. Axes may not be repeated.</p>"},{"location":"ref/#pywt.dwtn_max_level--returns","title":"Returns","text":"<p>level : int     Maximum level.</p>"},{"location":"ref/#pywt.dwtn_max_level--notes","title":"Notes","text":"<p>The level returned is the smallest <code>dwt_max_level</code> over all axes.</p>"},{"location":"ref/#pywt.dwtn_max_level--examples","title":"Examples","text":"<p>import pywt pywt.dwtn_max_level((64, 32), 'db2') 3</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def dwtn_max_level(shape, wavelet, axes=None):\n    \"\"\"Compute the maximum level of decomposition for n-dimensional data.\n\n    This returns the maximum number of levels of decomposition suitable for use\n    with ``wavedec``, ``wavedec2`` or ``wavedecn``.\n\n    Parameters\n    ----------\n    shape : sequence of ints\n        Input data shape.\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use. This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    axes : sequence of ints, optional\n        Axes over which to compute the DWT. Axes may not be repeated.\n\n    Returns\n    -------\n    level : int\n        Maximum level.\n\n    Notes\n    -----\n    The level returned is the smallest ``dwt_max_level`` over all axes.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; pywt.dwtn_max_level((64, 32), 'db2')\n    3\n    \"\"\"\n    # Determine the axes and shape for the transform\n    axes, axes_shapes, ndim_transform = _prep_axes_wavedecn(shape, axes)\n\n    # initialize a Wavelet object per (transformed) axis\n    wavelets = _wavelets_per_axis(wavelet, axes)\n\n    # maximum level of decomposition per axis\n    max_levels = [dwt_max_level(n, wav.dec_len)\n                  for n, wav in zip(axes_shapes, wavelets)]\n    return min(max_levels)\n</code></pre>"},{"location":"ref/#pywt.frequency2scale","title":"<code>frequency2scale(wavelet, freq, precision=8)</code>","text":"<p>Convert from to normalized frequency to CWT \"scale\".</p>"},{"location":"ref/#pywt.frequency2scale--parameters","title":"Parameters","text":"<p>wavelet : Wavelet instance or str     Wavelet to integrate.  If a string, should be the name of a wavelet. freq : scalar     Frequency, normalized so that the sampling frequency corresponds to a     value of 1.0. precision : int, optional     Precision that will be used for wavelet function approximation computed     with <code>wavelet.wavefun(level=precision)</code>.  Default is 8.</p>"},{"location":"ref/#pywt.frequency2scale--returns","title":"Returns","text":"<p>scale : scalar</p> Source code in <code>pywt/_functions.py</code> <pre><code>def frequency2scale(wavelet, freq, precision=8):\n    \"\"\"Convert from to normalized frequency to CWT \"scale\".\n\n    Parameters\n    ----------\n    wavelet : Wavelet instance or str\n        Wavelet to integrate.  If a string, should be the name of a wavelet.\n    freq : scalar\n        Frequency, normalized so that the sampling frequency corresponds to a\n        value of 1.0.\n    precision : int, optional\n        Precision that will be used for wavelet function approximation computed\n        with ``wavelet.wavefun(level=precision)``.  Default is 8.\n\n    Returns\n    -------\n    scale : scalar\n\n    \"\"\"\n    return central_frequency(wavelet, precision=precision) / freq\n</code></pre>"},{"location":"ref/#pywt.fswavedecn","title":"<code>fswavedecn(data, wavelet, mode='symmetric', levels=None, axes=None)</code>","text":"<p>Fully Separable Wavelet Decomposition.</p> <p>This is a variant of the multilevel discrete wavelet transform where all levels of decomposition are performed along a single axis prior to moving onto the next axis.  Unlike in <code>wavedecn</code>, the number of levels of decomposition are not required to be the same along each axis which can be a benefit for anisotropic data.</p>"},{"location":"ref/#pywt.fswavedecn--parameters","title":"Parameters","text":"<p>data: array_like     Input data wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or tuple of str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple containing a mode to apply along each axis in <code>axes</code>. levels : int or sequence of ints, optional     Decomposition levels along each axis (must be &gt;= 0). If an integer is     provided, the same number of levels are used for all axes. If     <code>levels</code> is None (default), <code>dwt_max_level</code> will be used to compute     the maximum number of levels possible for each axis. axes : sequence of ints, optional     Axes over which to compute the transform. Axes may not be repeated. The     default is to transform along all axes.</p>"},{"location":"ref/#pywt.fswavedecn--returns","title":"Returns","text":"<p>fswavedecn_result : FswavedecnResult object     Contains the wavelet coefficients, slice objects to allow obtaining     the coefficients per detail or approximation level, and more.     See <code>FswavedecnResult</code> for details.</p>"},{"location":"ref/#pywt.fswavedecn--examples","title":"Examples","text":"<p>import numpy as np from pywt import fswavedecn fs_result = fswavedecn(np.ones((32, 32)), 'sym2', levels=(1, 3)) print(fs_result.detail_keys()) [(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)] approx_coeffs = fs_result.approx detail_1_2 = fs_result[(1, 2)]</p>"},{"location":"ref/#pywt.fswavedecn--notes","title":"Notes","text":"<p>This transformation has been variously referred to as the (fully) separable wavelet transform (e.g. refs [1], [3]), the tensor-product wavelet ([2]) or the hyperbolic wavelet transform ([4]).  It is well suited to data with anisotropic smoothness.</p> <p>In [2]_ it was demonstrated that fully separable transform performs at least as well as the DWT for image compression.  Computation time is a factor 2 larger than that for the DWT.</p>"},{"location":"ref/#pywt.fswavedecn--see-also","title":"See Also","text":"<p>fswaverecn : inverse of fswavedecn</p>"},{"location":"ref/#pywt.fswavedecn--references","title":"References","text":"<p>.. [1] PH Westerink. Subband Coding of Images. Ph.D. dissertation, Dept.    Elect. Eng., Inf. Theory Group, Delft Univ. Technol., Delft, The    Netherlands, 1989.  (see Section 2.3)    http://resolver.tudelft.nl/uuid:a4d195c3-1f89-4d66-913d-db9af0969509</p> <p>.. [2] CP Rosiene and TQ Nguyen. Tensor-product wavelet vs. Mallat    decomposition: A comparative analysis, in Proc. IEEE Int. Symp.    Circuits and Systems, Orlando, FL, Jun. 1999, pp. 431-434.</p> <p>.. [3] V Velisavljevic, B Beferull-Lozano, M Vetterli and PL Dragotti.    Directionlets: Anisotropic Multidirectional Representation With    Separable Filtering. IEEE Transactions on Image Processing, Vol. 15,    No. 7, July 2006.</p> <p>.. [4] RA DeVore, SV Konyagin and VN Temlyakov. \"Hyperbolic wavelet    approximation,\" Constr. Approx. 14 (1998), 1-26.</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def fswavedecn(data, wavelet, mode='symmetric', levels=None, axes=None):\n    \"\"\"Fully Separable Wavelet Decomposition.\n\n    This is a variant of the multilevel discrete wavelet transform where all\n    levels of decomposition are performed along a single axis prior to moving\n    onto the next axis.  Unlike in ``wavedecn``, the number of levels of\n    decomposition are not required to be the same along each axis which can be\n    a benefit for anisotropic data.\n\n    Parameters\n    ----------\n    data: array_like\n        Input data\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or tuple of str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple containing a mode to apply along each axis in ``axes``.\n    levels : int or sequence of ints, optional\n        Decomposition levels along each axis (must be &gt;= 0). If an integer is\n        provided, the same number of levels are used for all axes. If\n        ``levels`` is None (default), ``dwt_max_level`` will be used to compute\n        the maximum number of levels possible for each axis.\n    axes : sequence of ints, optional\n        Axes over which to compute the transform. Axes may not be repeated. The\n        default is to transform along all axes.\n\n    Returns\n    -------\n    fswavedecn_result : FswavedecnResult object\n        Contains the wavelet coefficients, slice objects to allow obtaining\n        the coefficients per detail or approximation level, and more.\n        See ``FswavedecnResult`` for details.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pywt import fswavedecn\n    &gt;&gt;&gt; fs_result = fswavedecn(np.ones((32, 32)), 'sym2', levels=(1, 3))\n    &gt;&gt;&gt; print(fs_result.detail_keys())\n    [(0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3)]\n    &gt;&gt;&gt; approx_coeffs = fs_result.approx\n    &gt;&gt;&gt; detail_1_2 = fs_result[(1, 2)]\n\n\n    Notes\n    -----\n    This transformation has been variously referred to as the (fully) separable\n    wavelet transform (e.g. refs [1]_, [3]_), the tensor-product wavelet\n    ([2]_) or the hyperbolic wavelet transform ([4]_).  It is well suited to\n    data with anisotropic smoothness.\n\n    In [2]_ it was demonstrated that fully separable transform performs at\n    least as well as the DWT for image compression.  Computation time is a\n    factor 2 larger than that for the DWT.\n\n    See Also\n    --------\n    fswaverecn : inverse of fswavedecn\n\n    References\n    ----------\n    .. [1] PH Westerink. Subband Coding of Images. Ph.D. dissertation, Dept.\n       Elect. Eng., Inf. Theory Group, Delft Univ. Technol., Delft, The\n       Netherlands, 1989.  (see Section 2.3)\n       http://resolver.tudelft.nl/uuid:a4d195c3-1f89-4d66-913d-db9af0969509\n\n    .. [2] CP Rosiene and TQ Nguyen. Tensor-product wavelet vs. Mallat\n       decomposition: A comparative analysis, in Proc. IEEE Int. Symp.\n       Circuits and Systems, Orlando, FL, Jun. 1999, pp. 431-434.\n\n    .. [3] V Velisavljevic, B Beferull-Lozano, M Vetterli and PL Dragotti.\n       Directionlets: Anisotropic Multidirectional Representation With\n       Separable Filtering. IEEE Transactions on Image Processing, Vol. 15,\n       No. 7, July 2006.\n\n    .. [4] RA DeVore, SV Konyagin and VN Temlyakov. \"Hyperbolic wavelet\n       approximation,\" Constr. Approx. 14 (1998), 1-26.\n    \"\"\"\n    data = np.asarray(data)\n    if axes is None:\n        axes = tuple(np.arange(data.ndim))\n    _check_fswavedecn_axes(data, axes)\n\n    if levels is None or np.isscalar(levels):\n        levels = [levels, ] * len(axes)\n    if len(levels) != len(axes):\n        raise ValueError(\"levels must match the length of the axes list\")\n\n    modes = _modes_per_axis(mode, axes)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n\n    coeff_slices = [slice(None), ] * len(axes)\n    coeffs_arr = data\n    for ax_count, (ax, lev, wav, mode) in enumerate(\n            zip(axes, levels, wavelets, modes)):\n        coeffs = wavedec(coeffs_arr, wav, mode=mode, level=lev, axis=ax)\n\n        # Slice objects for accessing coefficient subsets.\n        # These can be used to access specific detail coefficient arrays\n        # (e.g. as needed for inverse transformation via fswaverecn).\n        c_shapes = [c.shape[ax] for c in coeffs]\n        c_offsets = np.cumsum([0, ] + c_shapes)\n        coeff_slices[ax_count] = [\n            slice(c_offsets[d], c_offsets[d+1]) for d in range(len(c_shapes))]\n\n        # stack the coefficients from all levels into a single array\n        coeffs_arr = np.concatenate(coeffs, axis=ax)\n\n    return FswavedecnResult(coeffs_arr, coeff_slices, wavelets, modes, axes)\n</code></pre>"},{"location":"ref/#pywt.fswaverecn","title":"<code>fswaverecn(fswavedecn_result)</code>","text":"<p>Fully Separable Inverse Wavelet Reconstruction.</p>"},{"location":"ref/#pywt.fswaverecn--parameters","title":"Parameters","text":"<p>fswavedecn_result : FswavedecnResult object     FswavedecnResult object from <code>fswavedecn</code>.</p>"},{"location":"ref/#pywt.fswaverecn--returns","title":"Returns","text":"<p>reconstructed : ndarray     Array of reconstructed data.</p>"},{"location":"ref/#pywt.fswaverecn--notes","title":"Notes","text":"<p>This transformation has been variously referred to as the (fully) separable wavelet transform (e.g. refs [1], [3]), the tensor-product wavelet ([2]) or the hyperbolic wavelet transform ([4]).  It is well suited to data with anisotropic smoothness.</p> <p>In [2]_ it was demonstrated that the fully separable transform performs at least as well as the DWT for image compression. Computation time is a factor 2 larger than that for the DWT.</p>"},{"location":"ref/#pywt.fswaverecn--see-also","title":"See Also","text":"<p>fswavedecn : inverse of fswaverecn</p>"},{"location":"ref/#pywt.fswaverecn--references","title":"References","text":"<p>.. [1] PH Westerink. Subband Coding of Images. Ph.D. dissertation, Dept.    Elect. Eng., Inf. Theory Group, Delft Univ. Technol., Delft, The    Netherlands, 1989.  (see Section 2.3)    http://resolver.tudelft.nl/uuid:a4d195c3-1f89-4d66-913d-db9af0969509</p> <p>.. [2] CP Rosiene and TQ Nguyen. Tensor-product wavelet vs. Mallat    decomposition: A comparative analysis, in Proc. IEEE Int. Symp.    Circuits and Systems, Orlando, FL, Jun. 1999, pp. 431-434.</p> <p>.. [3] V Velisavljevic, B Beferull-Lozano, M Vetterli and PL Dragotti.    Directionlets: Anisotropic Multidirectional Representation With    Separable Filtering. IEEE Transactions on Image Processing, Vol. 15,    No. 7, July 2006.</p> <p>.. [4] RA DeVore, SV Konyagin and VN Temlyakov. \"Hyperbolic wavelet    approximation,\" Constr. Approx. 14 (1998), 1-26.</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def fswaverecn(fswavedecn_result):\n    \"\"\"Fully Separable Inverse Wavelet Reconstruction.\n\n    Parameters\n    ----------\n    fswavedecn_result : FswavedecnResult object\n        FswavedecnResult object from ``fswavedecn``.\n\n    Returns\n    -------\n    reconstructed : ndarray\n        Array of reconstructed data.\n\n    Notes\n    -----\n    This transformation has been variously referred to as the (fully) separable\n    wavelet transform (e.g. refs [1]_, [3]_), the tensor-product wavelet\n    ([2]_) or the hyperbolic wavelet transform ([4]_).  It is well suited to\n    data with anisotropic smoothness.\n\n    In [2]_ it was demonstrated that the fully separable transform performs at\n    least as well as the DWT for image compression. Computation time is a\n    factor 2 larger than that for the DWT.\n\n    See Also\n    --------\n    fswavedecn : inverse of fswaverecn\n\n    References\n    ----------\n    .. [1] PH Westerink. Subband Coding of Images. Ph.D. dissertation, Dept.\n       Elect. Eng., Inf. Theory Group, Delft Univ. Technol., Delft, The\n       Netherlands, 1989.  (see Section 2.3)\n       http://resolver.tudelft.nl/uuid:a4d195c3-1f89-4d66-913d-db9af0969509\n\n    .. [2] CP Rosiene and TQ Nguyen. Tensor-product wavelet vs. Mallat\n       decomposition: A comparative analysis, in Proc. IEEE Int. Symp.\n       Circuits and Systems, Orlando, FL, Jun. 1999, pp. 431-434.\n\n    .. [3] V Velisavljevic, B Beferull-Lozano, M Vetterli and PL Dragotti.\n       Directionlets: Anisotropic Multidirectional Representation With\n       Separable Filtering. IEEE Transactions on Image Processing, Vol. 15,\n       No. 7, July 2006.\n\n    .. [4] RA DeVore, SV Konyagin and VN Temlyakov. \"Hyperbolic wavelet\n       approximation,\" Constr. Approx. 14 (1998), 1-26.\n    \"\"\"\n    coeffs_arr = fswavedecn_result.coeffs\n    coeff_slices = fswavedecn_result.coeff_slices\n    axes = fswavedecn_result.axes\n    modes = fswavedecn_result.modes\n    wavelets = fswavedecn_result.wavelets\n\n    _check_fswavedecn_axes(coeffs_arr, axes)\n    if len(axes) != len(coeff_slices):\n        raise ValueError(\"dimension mismatch\")\n\n    arr = coeffs_arr\n    csl = [slice(None), ] * arr.ndim\n    # for ax_count, (ax, wav, mode) in reversed(\n    #         list(enumerate(zip(axes, wavelets, modes)))):\n    for ax_count, (ax, wav, mode) in enumerate(zip(axes, wavelets, modes)):\n        coeffs = []\n        for sl in coeff_slices[ax_count]:\n            csl[ax] = sl\n            coeffs.append(arr[tuple(csl)])\n        csl[ax] = slice(None)\n        arr = waverec(coeffs, wav, mode=mode, axis=ax)\n    return arr\n</code></pre>"},{"location":"ref/#pywt.idwt","title":"<code>idwt(cA, cD, wavelet, mode='symmetric', axis=-1)</code>","text":"<p>idwt(cA, cD, wavelet, mode='symmetric', axis=-1)</p> <p>Single level Inverse Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.idwt--parameters","title":"Parameters","text":"<p>cA : array_like or None     Approximation coefficients.  If None, will be set to array of zeros     with same shape as <code>cD</code>. cD : array_like or None     Detail coefficients.  If None, will be set to array of zeros     with same shape as <code>cA</code>. wavelet : Wavelet object or name     Wavelet to use mode : str, optional (default: 'symmetric')     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. axis: int, optional     Axis over which to compute the inverse DWT. If not given, the     last axis is used.</p>"},{"location":"ref/#pywt.idwt--returns","title":"Returns","text":"<p>rec: array_like     Single level reconstruction of signal from given coefficients.</p>"},{"location":"ref/#pywt.idwt--examples","title":"Examples","text":"<p>import pywt (cA, cD) = pywt.dwt([1,2,3,4,5,6], 'db2', 'smooth') pywt.idwt(cA, cD, 'db2', 'smooth') array([ 1.,  2.,  3.,  4.,  5.,  6.])</p> <p>One of the neat features of <code>idwt</code> is that one of the <code>cA</code> and <code>cD</code> arguments can be set to None.  In that situation the reconstruction will be performed using only the other one.  Mathematically speaking, this is equivalent to passing a zero-filled array as one of the arguments.</p> <p>(cA, cD) = pywt.dwt([1,2,3,4,5,6], 'db2', 'smooth') A = pywt.idwt(cA, None, 'db2', 'smooth') D = pywt.idwt(None, cD, 'db2', 'smooth') A + D array([ 1.,  2.,  3.,  4.,  5.,  6.])</p> Source code in <code>pywt/_dwt.py</code> <pre><code>def idwt(cA, cD, wavelet, mode='symmetric', axis=-1):\n    \"\"\"\n    idwt(cA, cD, wavelet, mode='symmetric', axis=-1)\n\n    Single level Inverse Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    cA : array_like or None\n        Approximation coefficients.  If None, will be set to array of zeros\n        with same shape as ``cD``.\n    cD : array_like or None\n        Detail coefficients.  If None, will be set to array of zeros\n        with same shape as ``cA``.\n    wavelet : Wavelet object or name\n        Wavelet to use\n    mode : str, optional (default: 'symmetric')\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n    axis: int, optional\n        Axis over which to compute the inverse DWT. If not given, the\n        last axis is used.\n\n    Returns\n    -------\n    rec: array_like\n        Single level reconstruction of signal from given coefficients.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; (cA, cD) = pywt.dwt([1,2,3,4,5,6], 'db2', 'smooth')\n    &gt;&gt;&gt; pywt.idwt(cA, cD, 'db2', 'smooth')\n    array([ 1.,  2.,  3.,  4.,  5.,  6.])\n\n    One of the neat features of ``idwt`` is that one of the ``cA`` and ``cD``\n    arguments can be set to None.  In that situation the reconstruction will be\n    performed using only the other one.  Mathematically speaking, this is\n    equivalent to passing a zero-filled array as one of the arguments.\n\n    &gt;&gt;&gt; (cA, cD) = pywt.dwt([1,2,3,4,5,6], 'db2', 'smooth')\n    &gt;&gt;&gt; A = pywt.idwt(cA, None, 'db2', 'smooth')\n    &gt;&gt;&gt; D = pywt.idwt(None, cD, 'db2', 'smooth')\n    &gt;&gt;&gt; A + D\n    array([ 1.,  2.,  3.,  4.,  5.,  6.])\n\n    \"\"\"\n    # TODO: Lots of possible allocations to eliminate (zeros_like, asarray(rec))\n    # accept array_like input; make a copy to ensure a contiguous array\n\n    if cA is None and cD is None:\n        raise ValueError(\"At least one coefficient parameter must be \"\n                         \"specified.\")\n\n    # for complex inputs: compute real and imaginary separately then combine\n    if not _have_c99_complex and (np.iscomplexobj(cA) or np.iscomplexobj(cD)):\n        if cA is None:\n            cD = np.asarray(cD)\n            cA = np.zeros_like(cD)\n        elif cD is None:\n            cA = np.asarray(cA)\n            cD = np.zeros_like(cA)\n        return (idwt(cA.real, cD.real, wavelet, mode, axis) +\n                1j*idwt(cA.imag, cD.imag, wavelet, mode, axis))\n\n    if cA is not None:\n        dt = _check_dtype(cA)\n        cA = np.asarray(cA, dtype=dt, order='C')\n    if cD is not None:\n        dt = _check_dtype(cD)\n        cD = np.asarray(cD, dtype=dt, order='C')\n\n    if cA is not None and cD is not None:\n        if cA.dtype != cD.dtype:\n            # need to upcast to common type\n            if cA.dtype.kind == 'c' or cD.dtype.kind == 'c':\n                dtype = np.complex128\n            else:\n                dtype = np.float64\n            cA = cA.astype(dtype)\n            cD = cD.astype(dtype)\n    elif cA is None:\n        cA = np.zeros_like(cD)\n    elif cD is None:\n        cD = np.zeros_like(cA)\n\n    # cA and cD should be same dimension by here\n    ndim = cA.ndim\n\n    mode = Modes.from_object(mode)\n    wavelet = _as_wavelet(wavelet)\n\n    if axis &lt; 0:\n        axis = axis + ndim\n    if not 0 &lt;= axis &lt; ndim:\n        raise AxisError(\"Axis greater than coefficient dimensions\")\n\n    if ndim == 1:\n        rec = idwt_single(cA, cD, wavelet, mode)\n    else:\n        rec = idwt_axis(cA, cD, wavelet, mode, axis=axis)\n\n    return rec\n</code></pre>"},{"location":"ref/#pywt.idwt2","title":"<code>idwt2(coeffs, wavelet, mode='symmetric', axes=(-2, -1))</code>","text":"<p>2-D Inverse Discrete Wavelet Transform.</p> <p>Reconstructs data from coefficient arrays.</p>"},{"location":"ref/#pywt.idwt2--parameters","title":"Parameters","text":"<p>coeffs : tuple     (cA, (cH, cV, cD)) A tuple with approximation coefficients and three     details coefficients 2D arrays like from <code>dwt2</code>.  If any of these     components are set to <code>None</code>, it will be treated as zeros. wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or 2-tuple of strings, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple of modes specifying the mode to use on each axis in     <code>axes</code>. axes : 2-tuple of ints, optional     Axes over which to compute the IDWT. Repeated elements mean the IDWT     will be performed multiple times along these axes.</p>"},{"location":"ref/#pywt.idwt2--examples","title":"Examples","text":"<p>import numpy as np import pywt data = np.array([[1,2], [3,4]], dtype=np.float64) coeffs = pywt.dwt2(data, 'haar') pywt.idwt2(coeffs, 'haar') array([[ 1.,  2.],        [ 3.,  4.]])</p> Source code in <code>pywt/_multidim.py</code> <pre><code>def idwt2(coeffs, wavelet, mode='symmetric', axes=(-2, -1)):\n    \"\"\"\n    2-D Inverse Discrete Wavelet Transform.\n\n    Reconstructs data from coefficient arrays.\n\n    Parameters\n    ----------\n    coeffs : tuple\n        (cA, (cH, cV, cD)) A tuple with approximation coefficients and three\n        details coefficients 2D arrays like from ``dwt2``.  If any of these\n        components are set to ``None``, it will be treated as zeros.\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or 2-tuple of strings, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple of modes specifying the mode to use on each axis in\n        ``axes``.\n    axes : 2-tuple of ints, optional\n        Axes over which to compute the IDWT. Repeated elements mean the IDWT\n        will be performed multiple times along these axes.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; data = np.array([[1,2], [3,4]], dtype=np.float64)\n    &gt;&gt;&gt; coeffs = pywt.dwt2(data, 'haar')\n    &gt;&gt;&gt; pywt.idwt2(coeffs, 'haar')\n    array([[ 1.,  2.],\n           [ 3.,  4.]])\n\n    \"\"\"\n    # L -low-pass data, H - high-pass data\n    LL, (HL, LH, HH) = coeffs\n    axes = tuple(axes)\n    if len(axes) != 2:\n        raise ValueError(\"Expected 2 axes\")\n\n    coeffs = {'aa': LL, 'da': HL, 'ad': LH, 'dd': HH}\n    return idwtn(coeffs, wavelet, mode, axes)\n</code></pre>"},{"location":"ref/#pywt.idwtn","title":"<code>idwtn(coeffs, wavelet, mode='symmetric', axes=None)</code>","text":"<p>Single-level n-dimensional Inverse Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.idwtn--parameters","title":"Parameters","text":"<p>coeffs: dict     Dictionary as in output of <code>dwtn</code>. Missing or <code>None</code> items     will be treated as zeros. wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or list of string, optional     Signal extension mode used in the decomposition,     see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can also be a tuple of modes     specifying the mode to use on each axis in <code>axes</code>. axes : sequence of ints, optional     Axes over which to compute the IDWT. Repeated elements mean the IDWT     will be performed multiple times along these axes. A value of <code>None</code>     (the default) selects all axes.</p> <pre><code>For the most accurate reconstruction, the axes should be provided in\nthe same order as they were provided to ``dwtn``.\n</code></pre>"},{"location":"ref/#pywt.idwtn--returns","title":"Returns","text":"<p>data: ndarray     Original signal reconstructed from input data.</p> Source code in <code>pywt/_multidim.py</code> <pre><code>def idwtn(coeffs, wavelet, mode='symmetric', axes=None):\n    \"\"\"\n    Single-level n-dimensional Inverse Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    coeffs: dict\n        Dictionary as in output of ``dwtn``. Missing or ``None`` items\n        will be treated as zeros.\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or list of string, optional\n        Signal extension mode used in the decomposition,\n        see :ref:`Modes &lt;ref-modes&gt;`. This can also be a tuple of modes\n        specifying the mode to use on each axis in ``axes``.\n    axes : sequence of ints, optional\n        Axes over which to compute the IDWT. Repeated elements mean the IDWT\n        will be performed multiple times along these axes. A value of ``None``\n        (the default) selects all axes.\n\n        For the most accurate reconstruction, the axes should be provided in\n        the same order as they were provided to ``dwtn``.\n\n    Returns\n    -------\n    data: ndarray\n        Original signal reconstructed from input data.\n\n    \"\"\"\n\n    # drop the keys corresponding to value = None\n    coeffs = {k: v for k, v in coeffs.items() if v is not None}\n\n    # drop the keys corresponding to value = None\n    coeffs = {k: v for k, v in coeffs.items() if v is not None}\n\n    # Raise error for invalid key combinations\n    coeffs = _fix_coeffs(coeffs)\n\n    if (not _have_c99_complex and\n            any(np.iscomplexobj(v) for v in coeffs.values())):\n        real_coeffs = {k: v.real for k, v in coeffs.items()}\n        imag_coeffs = {k: v.imag for k, v in coeffs.items()}\n        return (idwtn(real_coeffs, wavelet, mode, axes) +\n                1j * idwtn(imag_coeffs, wavelet, mode, axes))\n\n    # key length matches the number of axes transformed\n    ndim_transform = max(len(key) for key in coeffs)\n\n    try:\n        coeff_shapes = (v.shape for k, v in coeffs.items()\n                        if v is not None and len(k) == ndim_transform)\n        coeff_shape = next(coeff_shapes)\n    except StopIteration:\n        raise ValueError(\"`coeffs` must contain at least one non-null wavelet \"\n                         \"band\")\n    if any(s != coeff_shape for s in coeff_shapes):\n        raise ValueError(\"`coeffs` must all be of equal size (or None)\")\n\n    if axes is None:\n        axes = range(ndim_transform)\n        ndim = ndim_transform\n    else:\n        ndim = len(coeff_shape)\n    axes = [a + ndim if a &lt; 0 else a for a in axes]\n\n    modes = _modes_per_axis(mode, axes)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n    for key_length, (axis, wav, mode) in reversed(\n            list(enumerate(zip(axes, wavelets, modes)))):\n        if axis &lt; 0 or axis &gt;= ndim:\n            raise AxisError(\"Axis greater than data dimensions\")\n\n        new_coeffs = {}\n        new_keys = [''.join(coef) for coef in product('ad', repeat=key_length)]\n\n        for key in new_keys:\n            L = coeffs.get(key + 'a', None)\n            H = coeffs.get(key + 'd', None)\n            if L is not None and H is not None:\n                if L.dtype != H.dtype:\n                    # upcast to a common dtype (float64 or complex128)\n                    if L.dtype.kind == 'c' or H.dtype.kind == 'c':\n                        dtype = np.complex128\n                    else:\n                        dtype = np.float64\n                    L = np.asarray(L, dtype=dtype)\n                    H = np.asarray(H, dtype=dtype)\n            new_coeffs[key] = idwt_axis(L, H, wav, mode, axis)\n        coeffs = new_coeffs\n\n    return coeffs['']\n</code></pre>"},{"location":"ref/#pywt.imra","title":"<code>imra(mra_coeffs)</code>","text":"<p>Inverse 1D multiresolution analysis via summation.</p>"},{"location":"ref/#pywt.imra--parameters","title":"Parameters","text":"<p>mra_coeffs : list of ndarray     Multiresolution analysis coefficients as returned by <code>mra</code>.</p>"},{"location":"ref/#pywt.imra--returns","title":"Returns","text":"<p>rec : ndarray     The reconstructed signal.</p>"},{"location":"ref/#pywt.imra--see-also","title":"See Also","text":"<p>mra</p>"},{"location":"ref/#pywt.imra--references","title":"References","text":"<p>.. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal     Coastal Sea Level Fluctuations Using Wavelets. Journal of the American     Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.     https://doi.org/10.2307/2965551</p> Source code in <code>pywt/_mra.py</code> <pre><code>def imra(mra_coeffs):\n    \"\"\"Inverse 1D multiresolution analysis via summation.\n\n    Parameters\n    ----------\n    mra_coeffs : list of ndarray\n        Multiresolution analysis coefficients as returned by `mra`.\n\n    Returns\n    -------\n    rec : ndarray\n        The reconstructed signal.\n\n    See Also\n    --------\n    mra\n\n    References\n    ----------\n    .. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal\n        Coastal Sea Level Fluctuations Using Wavelets. Journal of the American\n        Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.\n        https://doi.org/10.2307/2965551\n    \"\"\"\n    return reduce(lambda x, y: x + y, mra_coeffs)\n</code></pre>"},{"location":"ref/#pywt.imra2","title":"<code>imra2(mra_coeffs)</code>","text":"<p>Inverse 2D multiresolution analysis via summation.</p>"},{"location":"ref/#pywt.imra2--parameters","title":"Parameters","text":"<p>mra_coeffs : list     Multiresolution analysis coefficients as returned by <code>mra2</code>.</p>"},{"location":"ref/#pywt.imra2--returns","title":"Returns","text":"<p>rec : ndarray     The reconstructed signal.</p>"},{"location":"ref/#pywt.imra2--see-also","title":"See Also","text":"<p>mra2</p>"},{"location":"ref/#pywt.imra2--references","title":"References","text":"<p>.. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal     Coastal Sea Level Fluctuations Using Wavelets. Journal of the American     Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.     https://doi.org/10.2307/2965551</p> Source code in <code>pywt/_mra.py</code> <pre><code>def imra2(mra_coeffs):\n    \"\"\"Inverse 2D multiresolution analysis via summation.\n\n    Parameters\n    ----------\n    mra_coeffs : list\n        Multiresolution analysis coefficients as returned by `mra2`.\n\n    Returns\n    -------\n    rec : ndarray\n        The reconstructed signal.\n\n    See Also\n    --------\n    mra2\n\n    References\n    ----------\n    .. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal\n        Coastal Sea Level Fluctuations Using Wavelets. Journal of the American\n        Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.\n        https://doi.org/10.2307/2965551\n    \"\"\"\n    rec = mra_coeffs[0]\n    for j in range(1, len(mra_coeffs)):\n        for n in range(3):\n            rec += mra_coeffs[j][n]\n    return rec\n</code></pre>"},{"location":"ref/#pywt.imran","title":"<code>imran(mra_coeffs)</code>","text":"<p>Inverse nD multiresolution analysis via summation.</p>"},{"location":"ref/#pywt.imran--parameters","title":"Parameters","text":"<p>mra_coeffs : list     Multiresolution analysis coefficients as returned by <code>mra2</code>.</p>"},{"location":"ref/#pywt.imran--returns","title":"Returns","text":"<p>rec : ndarray     The reconstructed signal.</p>"},{"location":"ref/#pywt.imran--see-also","title":"See Also","text":"<p>mran</p>"},{"location":"ref/#pywt.imran--references","title":"References","text":"<p>.. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal     Coastal Sea Level Fluctuations Using Wavelets. Journal of the American     Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.     https://doi.org/10.2307/2965551</p> Source code in <code>pywt/_mra.py</code> <pre><code>def imran(mra_coeffs):\n    \"\"\"Inverse nD multiresolution analysis via summation.\n\n    Parameters\n    ----------\n    mra_coeffs : list\n        Multiresolution analysis coefficients as returned by `mra2`.\n\n    Returns\n    -------\n    rec : ndarray\n        The reconstructed signal.\n\n    See Also\n    --------\n    mran\n\n    References\n    ----------\n    .. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal\n        Coastal Sea Level Fluctuations Using Wavelets. Journal of the American\n        Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.\n        https://doi.org/10.2307/2965551\n    \"\"\"\n    rec = mra_coeffs[0]\n    for j in range(1, len(mra_coeffs)):\n        for k, v in mra_coeffs[j].items():\n            rec += v\n    return rec\n</code></pre>"},{"location":"ref/#pywt.integrate_wavelet","title":"<code>integrate_wavelet(wavelet, precision=8)</code>","text":"<p>Integrate <code>psi</code> wavelet function from -Inf to x using the rectangle integration method.</p>"},{"location":"ref/#pywt.integrate_wavelet--parameters","title":"Parameters","text":"<p>wavelet : Wavelet instance or str     Wavelet to integrate.  If a string, should be the name of a wavelet. precision : int, optional     Precision that will be used for wavelet function     approximation computed with the wavefun(level=precision)     Wavelet's method (default: 8).</p>"},{"location":"ref/#pywt.integrate_wavelet--returns","title":"Returns","text":"<p>[int_psi, x] :     for orthogonal wavelets [int_psi_d, int_psi_r, x] :     for other wavelets</p>"},{"location":"ref/#pywt.integrate_wavelet--examples","title":"Examples","text":"<p>from pywt import Wavelet, integrate_wavelet wavelet1 = Wavelet('db2') [int_psi, x] = integrate_wavelet(wavelet1, precision=5) wavelet2 = Wavelet('bior1.3') [int_psi_d, int_psi_r, x] = integrate_wavelet(wavelet2, precision=5)</p> Source code in <code>pywt/_functions.py</code> <pre><code>def integrate_wavelet(wavelet, precision=8):\n    \"\"\"\n    Integrate `psi` wavelet function from -Inf to x using the rectangle\n    integration method.\n\n    Parameters\n    ----------\n    wavelet : Wavelet instance or str\n        Wavelet to integrate.  If a string, should be the name of a wavelet.\n    precision : int, optional\n        Precision that will be used for wavelet function\n        approximation computed with the wavefun(level=precision)\n        Wavelet's method (default: 8).\n\n    Returns\n    -------\n    [int_psi, x] :\n        for orthogonal wavelets\n    [int_psi_d, int_psi_r, x] :\n        for other wavelets\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pywt import Wavelet, integrate_wavelet\n    &gt;&gt;&gt; wavelet1 = Wavelet('db2')\n    &gt;&gt;&gt; [int_psi, x] = integrate_wavelet(wavelet1, precision=5)\n    &gt;&gt;&gt; wavelet2 = Wavelet('bior1.3')\n    &gt;&gt;&gt; [int_psi_d, int_psi_r, x] = integrate_wavelet(wavelet2, precision=5)\n\n    \"\"\"\n    # FIXME: this function should really use scipy.integrate.quad\n\n    if type(wavelet) in (tuple, list):\n        msg = (\"Integration of a general signal is deprecated \"\n               \"and will be removed in a future version of pywt.\")\n        warnings.warn(msg, DeprecationWarning)\n    elif not isinstance(wavelet, (Wavelet, ContinuousWavelet)):\n        wavelet = DiscreteContinuousWavelet(wavelet)\n\n    if type(wavelet) in (tuple, list):\n        psi, x = np.asarray(wavelet[0]), np.asarray(wavelet[1])\n        step = x[1] - x[0]\n        return _integrate(psi, step), x\n\n    functions_approximations = wavelet.wavefun(precision)\n\n    if len(functions_approximations) == 2:      # continuous wavelet\n        psi, x = functions_approximations\n        step = x[1] - x[0]\n        return _integrate(psi, step), x\n\n    elif len(functions_approximations) == 3:    # orthogonal wavelet\n        phi, psi, x = functions_approximations\n        step = x[1] - x[0]\n        return _integrate(psi, step), x\n\n    else:                                       # biorthogonal wavelet\n        phi_d, psi_d, phi_r, psi_r, x = functions_approximations\n        step = x[1] - x[0]\n        return _integrate(psi_d, step), _integrate(psi_r, step), x\n</code></pre>"},{"location":"ref/#pywt.iswt","title":"<code>iswt(coeffs, wavelet, norm=False, axis=-1)</code>","text":"<p>Multilevel 1D inverse discrete stationary wavelet transform.</p>"},{"location":"ref/#pywt.iswt--parameters","title":"Parameters","text":"<p>coeffs : array_like     Coefficients list of tuples::</p> <pre><code>    [(cAn, cDn), ..., (cA2, cD2), (cA1, cD1)]\n\nwhere cA is approximation, cD is details.  Index 1 corresponds to\n``start_level`` from ``pywt.swt``.\n</code></pre> <p>wavelet : Wavelet object or name string     Wavelet to use norm : bool, optional     Controls the normalization used by the inverse transform. This must     be set equal to the value that was used by <code>pywt.swt</code> to preserve the     energy of a round-trip transform.</p>"},{"location":"ref/#pywt.iswt--returns","title":"Returns","text":"<p>1D array of reconstructed data.</p>"},{"location":"ref/#pywt.iswt--examples","title":"Examples","text":"<p>import pywt coeffs = pywt.swt([1,2,3,4,5,6,7,8], 'db2', level=2) pywt.iswt(coeffs, 'db2') array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])</p> Source code in <code>pywt/_swt.py</code> <pre><code>def iswt(coeffs, wavelet, norm=False, axis=-1):\n    \"\"\"\n    Multilevel 1D inverse discrete stationary wavelet transform.\n\n    Parameters\n    ----------\n    coeffs : array_like\n        Coefficients list of tuples::\n\n            [(cAn, cDn), ..., (cA2, cD2), (cA1, cD1)]\n\n        where cA is approximation, cD is details.  Index 1 corresponds to\n        ``start_level`` from ``pywt.swt``.\n    wavelet : Wavelet object or name string\n        Wavelet to use\n    norm : bool, optional\n        Controls the normalization used by the inverse transform. This must\n        be set equal to the value that was used by ``pywt.swt`` to preserve the\n        energy of a round-trip transform.\n\n    Returns\n    -------\n    1D array of reconstructed data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; coeffs = pywt.swt([1,2,3,4,5,6,7,8], 'db2', level=2)\n    &gt;&gt;&gt; pywt.iswt(coeffs, 'db2')\n    array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n    \"\"\"\n    # copy to avoid modification of input data\n    # If swt was called with trim_approx=False, first element is a tuple\n    trim_approx = not isinstance(coeffs[0], (tuple, list))\n    cA = coeffs[0] if trim_approx else coeffs[0][0]\n    if cA.ndim &gt; 1:\n        # convert to swtn coefficient format and call iswtn\n        if trim_approx:\n            coeffs_nd = [cA] + [{'d': d} for d in coeffs[1:]]\n        else:\n            coeffs_nd = [{'a': a, 'd': d} for a, d in coeffs]\n        return iswtn(coeffs_nd, wavelet, axes=(axis,), norm=norm)\n    elif axis != 0 and axis != -1:\n        raise AxisError(\"Axis greater than data dimensions\")\n    if not _have_c99_complex and np.iscomplexobj(cA):\n        if trim_approx:\n            coeffs_real = [c.real for c in coeffs]\n            coeffs_imag = [c.imag for c in coeffs]\n        else:\n            coeffs_real = [(ca.real, cd.real) for ca, cd in coeffs]\n            coeffs_imag = [(ca.imag, cd.imag) for ca, cd in coeffs]\n        kwargs = {\"wavelet\": wavelet, \"norm\": norm}\n        y = iswt(coeffs_real, **kwargs)\n        return y + 1j * iswt(coeffs_imag, **kwargs)\n\n    if trim_approx:\n        coeffs = coeffs[1:]\n\n    if cA.ndim != 1:\n        raise ValueError(\"iswt only supports 1D data\")\n\n    dt = _check_dtype(cA)\n    output = np.array(cA, dtype=dt, copy=True)\n\n    # num_levels, equivalent to the decomposition level, n\n    num_levels = len(coeffs)\n    wavelet = _as_wavelet(wavelet)\n    if norm:\n        wavelet = _rescale_wavelet_filterbank(wavelet, np.sqrt(2))\n    mode = Modes.from_object('periodization')\n    for j in range(num_levels, 0, -1):\n        step_size = int(pow(2, j-1))\n        last_index = step_size\n        if trim_approx:\n            cD = coeffs[-j]\n        else:\n            _, cD = coeffs[-j]\n        cD = np.asarray(cD, dtype=_check_dtype(cD))\n        if cD.dtype != output.dtype:\n            # upcast to a common dtype (float64 or complex128)\n            if output.dtype.kind == 'c' or cD.dtype.kind == 'c':\n                dtype = np.complex128\n            else:\n                dtype = np.float64\n            output = np.asarray(output, dtype=dtype)\n            cD = np.asarray(cD, dtype=dtype)\n        for first in range(last_index):  # 0 to last_index - 1\n\n            # Getting the indices that we will transform\n            indices = np.arange(first, len(cD), step_size)\n\n            # select the even indices\n            even_indices = indices[0::2]\n            # select the odd indices\n            odd_indices = indices[1::2]\n\n            # perform the inverse dwt on the selected indices,\n            # making sure to use periodic boundary conditions\n            # Note:  indexing with an array of ints returns a contiguous\n            #        copy as required by idwt_single.\n            x1 = idwt_single(output[even_indices],\n                             cD[even_indices],\n                             wavelet, mode)\n            x2 = idwt_single(output[odd_indices],\n                             cD[odd_indices],\n                             wavelet, mode)\n\n            # perform a circular shift right\n            x2 = np.roll(x2, 1)\n\n            # average and insert into the correct indices\n            output[indices] = (x1 + x2)/2.\n\n    return output\n</code></pre>"},{"location":"ref/#pywt.iswt2","title":"<code>iswt2(coeffs, wavelet, norm=False, axes=(-2, -1))</code>","text":"<p>Multilevel 2D inverse discrete stationary wavelet transform.</p>"},{"location":"ref/#pywt.iswt2--parameters","title":"Parameters","text":"<p>coeffs : list     Approximation and details coefficients::</p> <pre><code>    [\n        (cA_n,\n            (cH_n, cV_n, cD_n)\n        ),\n        ...,\n        (cA_2,\n            (cH_2, cV_2, cD_2)\n        ),\n        (cA_1,\n            (cH_1, cV_1, cD_1)\n        )\n    ]\n\nwhere cA is approximation, cH is horizontal details, cV is\nvertical details, cD is diagonal details and n is the number of\nlevels.  Index 1 corresponds to ``start_level`` from ``pywt.swt2``.\n</code></pre> <p>wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a 2-tuple of wavelets to apply per     axis. norm : bool, optional     Controls the normalization used by the inverse transform. This must     be set equal to the value that was used by <code>pywt.swt2</code> to preserve     the energy of a round-trip transform.</p>"},{"location":"ref/#pywt.iswt2--returns","title":"Returns","text":"<p>2D array of reconstructed data.</p>"},{"location":"ref/#pywt.iswt2--examples","title":"Examples","text":"<p>import pywt coeffs = pywt.swt2([[1,2,3,4],[5,6,7,8], ...                     [9,10,11,12],[13,14,15,16]], ...                    'db1', level=2) pywt.iswt2(coeffs, 'db1') array([[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.],        [ 13.,  14.,  15.,  16.]])</p> Source code in <code>pywt/_swt.py</code> <pre><code>def iswt2(coeffs, wavelet, norm=False, axes=(-2, -1)):\n    \"\"\"\n    Multilevel 2D inverse discrete stationary wavelet transform.\n\n    Parameters\n    ----------\n    coeffs : list\n        Approximation and details coefficients::\n\n            [\n                (cA_n,\n                    (cH_n, cV_n, cD_n)\n                ),\n                ...,\n                (cA_2,\n                    (cH_2, cV_2, cD_2)\n                ),\n                (cA_1,\n                    (cH_1, cV_1, cD_1)\n                )\n            ]\n\n        where cA is approximation, cH is horizontal details, cV is\n        vertical details, cD is diagonal details and n is the number of\n        levels.  Index 1 corresponds to ``start_level`` from ``pywt.swt2``.\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a 2-tuple of wavelets to apply per\n        axis.\n    norm : bool, optional\n        Controls the normalization used by the inverse transform. This must\n        be set equal to the value that was used by ``pywt.swt2`` to preserve\n        the energy of a round-trip transform.\n\n    Returns\n    -------\n    2D array of reconstructed data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; coeffs = pywt.swt2([[1,2,3,4],[5,6,7,8],\n    ...                     [9,10,11,12],[13,14,15,16]],\n    ...                    'db1', level=2)\n    &gt;&gt;&gt; pywt.iswt2(coeffs, 'db1')\n    array([[  1.,   2.,   3.,   4.],\n           [  5.,   6.,   7.,   8.],\n           [  9.,  10.,  11.,  12.],\n           [ 13.,  14.,  15.,  16.]])\n\n    \"\"\"\n\n    # If swt was called with trim_approx=False, first element is a tuple\n    trim_approx = not isinstance(coeffs[0], (tuple, list))\n    cA = coeffs[0] if trim_approx else coeffs[0][0]\n    if cA.ndim != 2 or axes != (-2, -1):\n        # convert to swtn coefficient format and call iswtn instead\n        if trim_approx:\n            coeffs_nd = [cA] + [{'da': h, 'ad': v, 'dd': d}\n                                for h, v, d in coeffs[1:]]\n        else:\n            coeffs_nd = [{'aa': a, 'da': h, 'ad': v, 'dd': d}\n                         for a, (h, v, d) in coeffs]\n        return iswtn(coeffs_nd, wavelet, axes=axes, norm=norm)\n    if not _have_c99_complex and np.iscomplexobj(cA):\n        if trim_approx:\n            coeffs_real = [cA.real]\n            coeffs_real += [(h.real, v.real, d.real) for h, v, d in coeffs[1:]]\n            coeffs_imag = [cA.imag]\n            coeffs_imag += [(h.imag, v.imag, d.imag) for h, v, d in coeffs[1:]]\n        else:\n            coeffs_real = [(a.real, (h.real, v.real, d.real))\n                            for a, (h, v, d) in coeffs]\n            coeffs_imag = [(a.imag, (h.imag, v.imag, d.imag))\n                            for a, (h, v, d) in coeffs]\n        kwargs = {\"wavelet\": wavelet, \"norm\": norm}\n        y = iswt2(coeffs_real, **kwargs)\n        return y + 1j * iswt2(coeffs_imag, **kwargs)\n\n    if trim_approx:\n        coeffs = coeffs[1:]\n\n    # copy to avoid modification of input data\n    dt = _check_dtype(cA)\n    output = np.array(cA, dtype=dt, copy=True)\n\n    if output.ndim != 2:\n        raise ValueError(\n            \"iswt2 only supports 2D arrays.  see iswtn for a general \"\n            \"n-dimensionsal ISWT\")\n    # num_levels, equivalent to the decomposition level, n\n    num_levels = len(coeffs)\n    wavelets = _wavelets_per_axis(wavelet, axes=(0, 1))\n    if norm:\n        wavelets = [_rescale_wavelet_filterbank(wav, np.sqrt(2))\n                    for wav in wavelets]\n\n    for j in range(num_levels):\n        step_size = int(pow(2, num_levels-j-1))\n        last_index = step_size\n        if trim_approx:\n            (cH, cV, cD) = coeffs[j]\n        else:\n            _, (cH, cV, cD) = coeffs[j]\n        # We are going to assume cH, cV, and cD are of equal size\n        if (cH.shape != cV.shape) or (cH.shape != cD.shape):\n            raise RuntimeError(\n                \"Mismatch in shape of intermediate coefficient arrays\")\n\n        # make sure output shares the common dtype\n        # (conversion of dtype for individual coeffs is handled within idwt2 )\n        common_dtype = np.result_type(*(\n            [dt, ] + [_check_dtype(c) for c in [cH, cV, cD]]))\n        if output.dtype != common_dtype:\n            output = output.astype(common_dtype)\n\n        for first_h in range(last_index):  # 0 to last_index - 1\n            for first_w in range(last_index):  # 0 to last_index - 1\n                # Getting the indices that we will transform\n                indices_h = slice(first_h, cH.shape[0], step_size)\n                indices_w = slice(first_w, cH.shape[1], step_size)\n\n                even_idx_h = slice(first_h, cH.shape[0], 2*step_size)\n                even_idx_w = slice(first_w, cH.shape[1], 2*step_size)\n                odd_idx_h = slice(first_h + step_size, cH.shape[0], 2*step_size)\n                odd_idx_w = slice(first_w + step_size, cH.shape[1], 2*step_size)\n\n                # perform the inverse dwt on the selected indices,\n                # making sure to use periodic boundary conditions\n                x1 = idwt2((output[even_idx_h, even_idx_w],\n                           (cH[even_idx_h, even_idx_w],\n                            cV[even_idx_h, even_idx_w],\n                            cD[even_idx_h, even_idx_w])),\n                           wavelets, 'periodization')\n                x2 = idwt2((output[even_idx_h, odd_idx_w],\n                           (cH[even_idx_h, odd_idx_w],\n                            cV[even_idx_h, odd_idx_w],\n                            cD[even_idx_h, odd_idx_w])),\n                           wavelets, 'periodization')\n                x3 = idwt2((output[odd_idx_h, even_idx_w],\n                           (cH[odd_idx_h, even_idx_w],\n                            cV[odd_idx_h, even_idx_w],\n                            cD[odd_idx_h, even_idx_w])),\n                           wavelets, 'periodization')\n                x4 = idwt2((output[odd_idx_h, odd_idx_w],\n                           (cH[odd_idx_h, odd_idx_w],\n                            cV[odd_idx_h, odd_idx_w],\n                            cD[odd_idx_h, odd_idx_w])),\n                           wavelets, 'periodization')\n\n                # perform a circular shifts\n                x2 = np.roll(x2, 1, axis=1)\n                x3 = np.roll(x3, 1, axis=0)\n                x4 = np.roll(x4, 1, axis=0)\n                x4 = np.roll(x4, 1, axis=1)\n                output[indices_h, indices_w] = (x1 + x2 + x3 + x4) / 4\n\n    return output\n</code></pre>"},{"location":"ref/#pywt.iswtn","title":"<code>iswtn(coeffs, wavelet, axes=None, norm=False)</code>","text":"<p>Multilevel nD inverse discrete stationary wavelet transform.</p>"},{"location":"ref/#pywt.iswtn--parameters","title":"Parameters","text":"<p>coeffs : list     [{coeffs_level_n}, ..., {coeffs_level_1}]: list of dict wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple of wavelets to apply per     axis in <code>axes</code>. axes : sequence of ints, optional     Axes over which to compute the inverse SWT. Axes may not be repeated.     The default is <code>None</code>, which means transform all axes     (<code>axes = range(data.ndim)</code>). norm : bool, optional     Controls the normalization used by the inverse transform. This must     be set equal to the value that was used by <code>pywt.swtn</code> to preserve     the energy of a round-trip transform.</p>"},{"location":"ref/#pywt.iswtn--returns","title":"Returns","text":"<p>nD array of reconstructed data.</p>"},{"location":"ref/#pywt.iswtn--examples","title":"Examples","text":"<p>import pywt coeffs = pywt.swtn([[1,2,3,4],[5,6,7,8], ...                     [9,10,11,12],[13,14,15,16]], ...                    'db1', level=2) pywt.iswtn(coeffs, 'db1') array([[  1.,   2.,   3.,   4.],        [  5.,   6.,   7.,   8.],        [  9.,  10.,  11.,  12.],        [ 13.,  14.,  15.,  16.]])</p> Source code in <code>pywt/_swt.py</code> <pre><code>def iswtn(coeffs, wavelet, axes=None, norm=False):\n    \"\"\"\n    Multilevel nD inverse discrete stationary wavelet transform.\n\n    Parameters\n    ----------\n    coeffs : list\n        [{coeffs_level_n}, ..., {coeffs_level_1}]: list of dict\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple of wavelets to apply per\n        axis in ``axes``.\n    axes : sequence of ints, optional\n        Axes over which to compute the inverse SWT. Axes may not be repeated.\n        The default is ``None``, which means transform all axes\n        (``axes = range(data.ndim)``).\n    norm : bool, optional\n        Controls the normalization used by the inverse transform. This must\n        be set equal to the value that was used by ``pywt.swtn`` to preserve\n        the energy of a round-trip transform.\n\n    Returns\n    -------\n    nD array of reconstructed data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; coeffs = pywt.swtn([[1,2,3,4],[5,6,7,8],\n    ...                     [9,10,11,12],[13,14,15,16]],\n    ...                    'db1', level=2)\n    &gt;&gt;&gt; pywt.iswtn(coeffs, 'db1')\n    array([[  1.,   2.,   3.,   4.],\n           [  5.,   6.,   7.,   8.],\n           [  9.,  10.,  11.,  12.],\n           [ 13.,  14.,  15.,  16.]])\n\n    \"\"\"\n\n    # key length matches the number of axes transformed\n    ndim_transform = max(len(key) for key in coeffs[-1])\n    trim_approx = not isinstance(coeffs[0], dict)\n    cA = coeffs[0] if trim_approx else coeffs[0]['a'*ndim_transform]\n\n    if not _have_c99_complex and np.iscomplexobj(cA):\n        if trim_approx:\n            coeffs_real = [coeffs[0].real]\n            coeffs_imag = [coeffs[0].imag]\n            coeffs = coeffs[1:]\n        else:\n            coeffs_real = []\n            coeffs_imag = []\n        coeffs_real += [{k: v.real for k, v in c.items()} for c in coeffs]\n        coeffs_imag += [{k: v.imag for k, v in c.items()} for c in coeffs]\n        kwargs = {\"wavelet\": wavelet, \"axes\": axes, \"norm\": norm}\n        y = iswtn(coeffs_real, **kwargs)\n        return y + 1j * iswtn(coeffs_imag, **kwargs)\n\n    if trim_approx:\n        coeffs = coeffs[1:]\n\n    # copy to avoid modification of input data\n    dt = _check_dtype(cA)\n    output = np.array(cA, dtype=dt, copy=True)\n    ndim = output.ndim\n\n    if axes is None:\n        axes = range(output.ndim)\n    axes = [a + ndim if a &lt; 0 else a for a in axes]\n    if len(axes) != len(set(axes)):\n        raise ValueError(\"The axes passed to swtn must be unique.\")\n    if ndim_transform != len(axes):\n        raise ValueError(\"The number of axes used in iswtn must match the \"\n                         \"number of dimensions transformed in swtn.\")\n\n    # num_levels, equivalent to the decomposition level, n\n    num_levels = len(coeffs)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n    if norm:\n        wavelets = [_rescale_wavelet_filterbank(wav, np.sqrt(2))\n                    for wav in wavelets]\n\n    # initialize various slice objects used in the loops below\n    # these will remain slice(None) only on axes that aren't transformed\n    indices = [slice(None), ]*ndim\n    even_indices = [slice(None), ]*ndim\n    odd_indices = [slice(None), ]*ndim\n    odd_even_slices = [slice(None), ]*ndim\n\n    for j in range(num_levels):\n        step_size = int(pow(2, num_levels-j-1))\n        last_index = step_size\n        if not trim_approx:\n            a = coeffs[j].pop('a'*ndim_transform)  # will restore later\n        details = coeffs[j]\n        # make sure dtype matches the coarsest level approximation coefficients\n        common_dtype = np.result_type(*(\n            [dt, ] + [v.dtype for v in details.values()]))\n        if output.dtype != common_dtype:\n            output = output.astype(common_dtype)\n\n        # We assume all coefficient arrays are of equal size\n        shapes = [v.shape for k, v in details.items()]\n        if len(set(shapes)) != 1:\n            raise RuntimeError(\n                \"Mismatch in shape of intermediate coefficient arrays\")\n\n        # shape of a single coefficient array, excluding non-transformed axes\n        coeff_trans_shape = tuple([shapes[0][ax] for ax in axes])\n\n        # nested loop over all combinations of axis offsets at this level\n        for firsts in product(*([range(last_index), ]*ndim_transform)):\n            for first, sh, ax in zip(firsts, coeff_trans_shape, axes):\n                indices[ax] = slice(first, sh, step_size)\n                even_indices[ax] = slice(first, sh, 2*step_size)\n                odd_indices[ax] = slice(first+step_size, sh, 2*step_size)\n\n            # nested loop over all combinations of odd/even inidices\n            approx = output.copy()\n            output[tuple(indices)] = 0\n            ntransforms = 0\n            for odds in product(*([(0, 1), ]*ndim_transform)):\n                for o, ax in zip(odds, axes):\n                    if o:\n                        odd_even_slices[ax] = odd_indices[ax]\n                    else:\n                        odd_even_slices[ax] = even_indices[ax]\n                # extract the odd/even indices for all detail coefficients\n                details_slice = {}\n                for key, value in details.items():\n                    details_slice[key] = value[tuple(odd_even_slices)]\n                details_slice['a'*ndim_transform] = approx[\n                    tuple(odd_even_slices)]\n\n                # perform the inverse dwt on the selected indices,\n                # making sure to use periodic boundary conditions\n                x = idwtn(details_slice, wavelets, 'periodization', axes=axes)\n                for o, ax in zip(odds, axes):\n                    # circular shift along any odd indexed axis\n                    if o:\n                        x = np.roll(x, 1, axis=ax)\n                output[tuple(indices)] += x\n                ntransforms += 1\n            output[tuple(indices)] /= ntransforms  # normalize\n        if not trim_approx:\n            coeffs[j]['a'*ndim_transform] = a  # restore approx coeffs to dict\n    return output\n</code></pre>"},{"location":"ref/#pywt.mra","title":"<code>mra(data, wavelet, level=None, axis=-1, transform='swt', mode='periodization')</code>","text":"<p>Forward 1D multiresolution analysis.</p> <p>It is a projection onto the wavelet subspaces.</p>"},{"location":"ref/#pywt.mra--parameters","title":"Parameters","text":"<p>data: array_like     Input data wavelet : Wavelet object or name string     Wavelet to use level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axis: int, optional     Axis over which to compute the DWT. If not given, the last axis is     used. Currently only available when <code>transform='dwt'</code>. transform : {'dwt', 'swt'}     Whether to use the DWT or SWT for the transforms. mode : str, optional     Signal extension mode, see <code>Modes</code> (default: 'symmetric'). This option     is only used when transform='dwt'.</p>"},{"location":"ref/#pywt.mra--returns","title":"Returns","text":"<p>[cAn, {details_level_n}, ... {details_level_1}] : list     For more information, see the detailed description in <code>wavedec</code></p>"},{"location":"ref/#pywt.mra--see-also","title":"See Also","text":"<p>imra, swt</p>"},{"location":"ref/#pywt.mra--notes","title":"Notes","text":"<p>This is sometimes referred to as an additive decomposition because the inverse transform (<code>imra</code>) is just the sum of the coefficient arrays [1]_. The decomposition using <code>transform='dwt'</code> corresponds to section 2.2 while that using an undecimated transform (<code>transform='swt'</code>) is described in section 3.2 and appendix A.</p> <p>This transform does not share the variance partition property of <code>swt</code> with <code>norm=True</code>. It does however, result in coefficients that are temporally aligned regardless of the symmetry of the wavelet used.</p> <p>The redundancy of this transform is <code>(level + 1)</code>.</p>"},{"location":"ref/#pywt.mra--references","title":"References","text":"<p>.. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal     Coastal Sea Level Fluctuations Using Wavelets. Journal of the American     Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.     https://doi.org/10.2307/2965551</p> Source code in <code>pywt/_mra.py</code> <pre><code>def mra(data, wavelet, level=None, axis=-1, transform='swt',\n        mode='periodization'):\n    \"\"\"Forward 1D multiresolution analysis.\n\n    It is a projection onto the wavelet subspaces.\n\n    Parameters\n    ----------\n    data: array_like\n        Input data\n    wavelet : Wavelet object or name string\n        Wavelet to use\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the `dwt_max_level` function.\n    axis: int, optional\n        Axis over which to compute the DWT. If not given, the last axis is\n        used. Currently only available when ``transform='dwt'``.\n    transform : {'dwt', 'swt'}\n        Whether to use the DWT or SWT for the transforms.\n    mode : str, optional\n        Signal extension mode, see `Modes` (default: 'symmetric'). This option\n        is only used when transform='dwt'.\n\n    Returns\n    -------\n    [cAn, {details_level_n}, ... {details_level_1}] : list\n        For more information, see the detailed description in `wavedec`\n\n    See Also\n    --------\n    imra, swt\n\n    Notes\n    -----\n    This is sometimes referred to as an additive decomposition because the\n    inverse transform (``imra``) is just the sum of the coefficient arrays\n    [1]_. The decomposition using ``transform='dwt'`` corresponds to section\n    2.2 while that using an undecimated transform (``transform='swt'``) is\n    described in section 3.2 and appendix A.\n\n    This transform does not share the variance partition property of ``swt``\n    with `norm=True`. It does however, result in coefficients that are\n    temporally aligned regardless of the symmetry of the wavelet used.\n\n    The redundancy of this transform is ``(level + 1)``.\n\n    References\n    ----------\n    .. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal\n        Coastal Sea Level Fluctuations Using Wavelets. Journal of the American\n        Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.\n        https://doi.org/10.2307/2965551\n\n    \"\"\"\n    if transform == 'swt':\n        if mode != 'periodization':\n            raise ValueError(\n                \"transform swt only supports mode='periodization'\")\n        kwargs = {\"wavelet\": wavelet, \"axis\": axis, \"norm\": True}\n        forward = partial(swt, level=level, trim_approx=True, **kwargs)\n        inverse = partial(iswt, **kwargs)\n        is_swt = True\n    elif transform == 'dwt':\n        kwargs = {\"wavelet\": wavelet, \"mode\": mode, \"axis\": axis}\n        forward = partial(wavedec, level=level, **kwargs)\n        inverse = partial(waverec, **kwargs)\n        is_swt = False\n    else:\n        raise ValueError(f\"unrecognized transform: {transform}\")\n\n    wav_coeffs = forward(data)\n\n    mra_coeffs = []\n    nc = len(wav_coeffs)\n\n    if is_swt:\n        # replicate same zeros array to save memory\n        z = np.zeros_like(wav_coeffs[0])\n        tmp = [z, ] * nc\n    else:\n        # zero arrays have variable size in DWT case\n        tmp = [np.zeros_like(c) for c in wav_coeffs]\n\n    for j in range(nc):\n        # tmp has arrays of zeros except for the jth entry\n        tmp[j] = wav_coeffs[j]\n\n        # reconstruct\n        rec = inverse(tmp)\n        if rec.shape != data.shape:\n            # trim any excess coefficients\n            rec = rec[tuple([slice(sz) for sz in data.shape])]\n        mra_coeffs.append(rec)\n\n        # restore zeros\n        if is_swt:\n            tmp[j] = z\n        else:\n            tmp[j] = np.zeros_like(tmp[j])\n    return mra_coeffs\n</code></pre>"},{"location":"ref/#pywt.mra2","title":"<code>mra2(data, wavelet, level=None, axes=(-2, -1), transform='swt2', mode='periodization')</code>","text":"<p>Forward 2D multiresolution analysis.</p> <p>It is a projection onto wavelet subspaces.</p>"},{"location":"ref/#pywt.mra2--parameters","title":"Parameters","text":"<p>data: array_like     Input data wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axes : 2-tuple of ints, optional     Axes over which to compute the DWT. Repeated elements are not allowed.     Currently only available when <code>transform='dwt2'</code>. transform : {'dwt2', 'swt2'}     Whether to use the DWT or SWT for the transforms. mode : str or 2-tuple of str, optional     Signal extension mode, see <code>Modes</code> (default: 'symmetric'). This option     is only used when transform='dwt2'.</p>"},{"location":"ref/#pywt.mra2--returns","title":"Returns","text":"<p>coeffs : list     For more information, see the detailed description in <code>wavedec2</code></p>"},{"location":"ref/#pywt.mra2--notes","title":"Notes","text":"<p>This is sometimes referred to as an additive decomposition because the inverse transform (<code>imra2</code>) is just the sum of the coefficient arrays [1]_. The decomposition using <code>transform='dwt'</code> corresponds to section 2.2 while that using an undecimated transform (<code>transform='swt'</code>) is described in section 3.2 and appendix A.</p> <p>This transform does not share the variance partition property of <code>swt2</code> with <code>norm=True</code>. It does however, result in coefficients that are temporally aligned regardless of the symmetry of the wavelet used.</p> <p>The redundancy of this transform is <code>3 * level + 1</code>.</p>"},{"location":"ref/#pywt.mra2--see-also","title":"See Also","text":"<p>imra2, swt2</p>"},{"location":"ref/#pywt.mra2--references","title":"References","text":"<p>.. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal     Coastal Sea Level Fluctuations Using Wavelets. Journal of the American     Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.     https://doi.org/10.2307/2965551</p> Source code in <code>pywt/_mra.py</code> <pre><code>def mra2(data, wavelet, level=None, axes=(-2, -1), transform='swt2',\n         mode='periodization'):\n    \"\"\"Forward 2D multiresolution analysis.\n\n    It is a projection onto wavelet subspaces.\n\n    Parameters\n    ----------\n    data: array_like\n        Input data\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in `axes`.\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the `dwt_max_level` function.\n    axes : 2-tuple of ints, optional\n        Axes over which to compute the DWT. Repeated elements are not allowed.\n        Currently only available when ``transform='dwt2'``.\n    transform : {'dwt2', 'swt2'}\n        Whether to use the DWT or SWT for the transforms.\n    mode : str or 2-tuple of str, optional\n        Signal extension mode, see `Modes` (default: 'symmetric'). This option\n        is only used when transform='dwt2'.\n\n    Returns\n    -------\n    coeffs : list\n        For more information, see the detailed description in `wavedec2`\n\n    Notes\n    -----\n    This is sometimes referred to as an additive decomposition because the\n    inverse transform (``imra2``) is just the sum of the coefficient arrays\n    [1]_. The decomposition using ``transform='dwt'`` corresponds to section\n    2.2 while that using an undecimated transform (``transform='swt'``) is\n    described in section 3.2 and appendix A.\n\n    This transform does not share the variance partition property of ``swt2``\n    with `norm=True`. It does however, result in coefficients that are\n    temporally aligned regardless of the symmetry of the wavelet used.\n\n    The redundancy of this transform is ``3 * level + 1``.\n\n    See Also\n    --------\n    imra2, swt2\n\n    References\n    ----------\n    .. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal\n        Coastal Sea Level Fluctuations Using Wavelets. Journal of the American\n        Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.\n        https://doi.org/10.2307/2965551\n    \"\"\"\n    if transform == 'swt2':\n        if mode != 'periodization':\n            raise ValueError(\n                \"transform swt only supports mode='periodization'\")\n        if level is None:\n            level = min(swt_max_level(s) for s in data.shape)\n        kwargs = {\"wavelet\": wavelet, \"axes\": axes, \"norm\": True}\n        forward = partial(swt2, level=level, trim_approx=True, **kwargs)\n        inverse = partial(iswt2, **kwargs)\n    elif transform == 'dwt2':\n        kwargs = {\"wavelet\": wavelet, \"mode\": mode, \"axes\": axes}\n        forward = partial(wavedec2, level=level, **kwargs)\n        inverse = partial(waverec2, **kwargs)\n    else:\n        raise ValueError(f\"unrecognized transform: {transform}\")\n\n    wav_coeffs = forward(data)\n\n    mra_coeffs = []\n    nc = len(wav_coeffs)\n    z = np.zeros_like(wav_coeffs[0])\n    tmp = [z]\n    for j in range(1, nc):\n        tmp.append([np.zeros_like(c) for c in wav_coeffs[j]])\n\n    # tmp has arrays of zeros except for the jth entry\n    tmp[0] = wav_coeffs[0]\n    # reconstruct\n    rec = inverse(tmp)\n    if rec.shape != data.shape:\n        # trim any excess coefficients\n        rec = rec[tuple([slice(sz) for sz in data.shape])]\n    mra_coeffs.append(rec)\n    # restore zeros\n    tmp[0] = z\n\n    for j in range(1, nc):\n        dcoeffs = []\n        for n in range(3):\n            # tmp has arrays of zeros except for the jth entry\n            z = tmp[j][n]\n            tmp[j][n] = wav_coeffs[j][n]\n            # reconstruct\n            rec = inverse(tmp)\n            if rec.shape != data.shape:\n                # trim any excess coefficients\n                rec = rec[tuple([slice(sz) for sz in data.shape])]\n            dcoeffs.append(rec)\n            # restore zeros\n            tmp[j][n] = z\n        mra_coeffs.append(tuple(dcoeffs))\n    return mra_coeffs\n</code></pre>"},{"location":"ref/#pywt.mran","title":"<code>mran(data, wavelet, level=None, axes=None, transform='swtn', mode='periodization')</code>","text":"<p>Forward nD multiresolution analysis.</p> <p>It is a projection onto the wavelet subspaces.</p>"},{"location":"ref/#pywt.mran--parameters","title":"Parameters","text":"<p>data: array_like     Input data wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use. This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axes : tuple of ints, optional     Axes over which to compute the DWT. Repeated elements are not allowed. transform : {'dwtn', 'swtn'}     Whether to use the DWT or SWT for the transforms. mode : str or tuple of str, optional     Signal extension mode, see <code>Modes</code> (default: 'symmetric'). This option     is only used when transform='dwtn'.</p>"},{"location":"ref/#pywt.mran--returns","title":"Returns","text":"<p>coeffs : list     For more information, see the detailed description in <code>wavedecn</code>.</p>"},{"location":"ref/#pywt.mran--see-also","title":"See Also","text":"<p>imran, swtn</p>"},{"location":"ref/#pywt.mran--notes","title":"Notes","text":"<p>This is sometimes referred to as an additive decomposition because the inverse transform (<code>imran</code>) is just the sum of the coefficient arrays [1]_. The decomposition using <code>transform='dwt'</code> corresponds to section 2.2 while that using an undecimated transform (<code>transform='swt'</code>) is described in section 3.2 and appendix A.</p> <p>This transform does not share the variance partition property of <code>swtn</code> with <code>norm=True</code>. It does however, result in coefficients that are temporally aligned regardless of the symmetry of the wavelet used.</p> <p>The redundancy of this transform is <code>(2**n - 1) * level + 1</code> where <code>n</code> corresponds to the number of axes transformed.</p>"},{"location":"ref/#pywt.mran--references","title":"References","text":"<p>.. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal     Coastal Sea Level Fluctuations Using Wavelets. Journal of the American     Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.     https://doi.org/10.2307/2965551</p> Source code in <code>pywt/_mra.py</code> <pre><code>def mran(data, wavelet, level=None, axes=None, transform='swtn',\n         mode='periodization'):\n    \"\"\"Forward nD multiresolution analysis.\n\n    It is a projection onto the wavelet subspaces.\n\n    Parameters\n    ----------\n    data: array_like\n        Input data\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use. This can also be a tuple containing a wavelet to\n        apply along each axis in `axes`.\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the `dwt_max_level` function.\n    axes : tuple of ints, optional\n        Axes over which to compute the DWT. Repeated elements are not allowed.\n    transform : {'dwtn', 'swtn'}\n        Whether to use the DWT or SWT for the transforms.\n    mode : str or tuple of str, optional\n        Signal extension mode, see `Modes` (default: 'symmetric'). This option\n        is only used when transform='dwtn'.\n\n    Returns\n    -------\n    coeffs : list\n        For more information, see the detailed description in `wavedecn`.\n\n    See Also\n    --------\n    imran, swtn\n\n    Notes\n    -----\n    This is sometimes referred to as an additive decomposition because the\n    inverse transform (``imran``) is just the sum of the coefficient arrays\n    [1]_. The decomposition using ``transform='dwt'`` corresponds to section\n    2.2 while that using an undecimated transform (``transform='swt'``) is\n    described in section 3.2 and appendix A.\n\n    This transform does not share the variance partition property of ``swtn``\n    with `norm=True`. It does however, result in coefficients that are\n    temporally aligned regardless of the symmetry of the wavelet used.\n\n    The redundancy of this transform is ``(2**n - 1) * level + 1`` where ``n``\n    corresponds to the number of axes transformed.\n\n    References\n    ----------\n    .. [1] Donald B. Percival and Harold O. Mofjeld. Analysis of Subtidal\n        Coastal Sea Level Fluctuations Using Wavelets. Journal of the American\n        Statistical Association Vol. 92, No. 439 (Sep., 1997), pp. 868-880.\n        https://doi.org/10.2307/2965551\n    \"\"\"\n    axes, axes_shapes, ndim_transform = _prep_axes_wavedecn(data.shape, axes)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n\n    if transform == 'swtn':\n        if mode != 'periodization':\n            raise ValueError(\n                \"transform swt only supports mode='periodization'\")\n        if level is None:\n            level = min(swt_max_level(s) for s in data.shape)\n        kwargs = {\"wavelet\": wavelets, \"axes\": axes, \"norm\": True}\n        forward = partial(swtn, level=level, trim_approx=True, **kwargs)\n        inverse = partial(iswtn, **kwargs)\n    elif transform == 'dwtn':\n        modes = _modes_per_axis(mode, axes)\n        kwargs = {\"wavelet\": wavelets, \"mode\": modes, \"axes\": axes}\n        forward = partial(wavedecn, level=level, **kwargs)\n        inverse = partial(waverecn, **kwargs)\n    else:\n        raise ValueError(f\"unrecognized transform: {transform}\")\n\n    wav_coeffs = forward(data)\n\n    mra_coeffs = []\n    nc = len(wav_coeffs)\n    z = np.zeros_like(wav_coeffs[0])\n    tmp = [z]\n    for j in range(1, nc):\n        tmp.append({k: np.zeros_like(v) for k, v in wav_coeffs[j].items()})\n\n    # tmp has arrays of zeros except for the jth entry\n    tmp[0] = wav_coeffs[0]\n    # reconstruct\n    rec = inverse(tmp)\n    if rec.shape != data.shape:\n        # trim any excess coefficients\n        rec = rec[tuple([slice(sz) for sz in data.shape])]\n    mra_coeffs.append(rec)\n    # restore zeros\n    tmp[0] = z\n\n    for j in range(1, nc):\n        dcoeffs = {}\n        dkeys = list(wav_coeffs[j].keys())\n        for k in dkeys:\n            # tmp has arrays of zeros except for the jth entry\n            z = tmp[j][k]\n            tmp[j][k] = wav_coeffs[j][k]\n            # tmp[j]['a' * len(k)] = z\n            # reconstruct\n            rec = inverse(tmp)\n            if rec.shape != data.shape:\n                # trim any excess coefficients\n                rec = rec[tuple([slice(sz) for sz in data.shape])]\n            dcoeffs[k] = rec\n            # restore zeros\n            tmp[j][k] = z\n            # tmp[j].pop('a' * len(k))\n        mra_coeffs.append(dcoeffs)\n    return mra_coeffs\n</code></pre>"},{"location":"ref/#pywt.orthogonal_filter_bank","title":"<code>orthogonal_filter_bank(scaling_filter)</code>","text":"<p>Returns the orthogonal filter bank.</p> <p>The orthogonal filter bank consists of the HPFs and LPFs at decomposition and reconstruction stage for the input scaling filter.</p>"},{"location":"ref/#pywt.orthogonal_filter_bank--parameters","title":"Parameters","text":"<p>scaling_filter : array_like     Input scaling filter (father wavelet).</p>"},{"location":"ref/#pywt.orthogonal_filter_bank--returns","title":"Returns","text":"<p>orth_filt_bank : tuple of 4 ndarrays     The orthogonal filter bank of the input scaling filter in the order :     1] Decomposition LPF     2] Decomposition HPF     3] Reconstruction LPF     4] Reconstruction HPF</p> Source code in <code>pywt/_functions.py</code> <pre><code>def orthogonal_filter_bank(scaling_filter):\n    \"\"\"\n    Returns the orthogonal filter bank.\n\n    The orthogonal filter bank consists of the HPFs and LPFs at\n    decomposition and reconstruction stage for the input scaling filter.\n\n    Parameters\n    ----------\n    scaling_filter : array_like\n        Input scaling filter (father wavelet).\n\n    Returns\n    -------\n    orth_filt_bank : tuple of 4 ndarrays\n        The orthogonal filter bank of the input scaling filter in the order :\n        1] Decomposition LPF\n        2] Decomposition HPF\n        3] Reconstruction LPF\n        4] Reconstruction HPF\n\n    \"\"\"\n    if not (len(scaling_filter) % 2 == 0):\n        raise ValueError(\"`scaling_filter` length has to be even.\")\n\n    scaling_filter = np.asarray(scaling_filter, dtype=np.float64)\n\n    rec_lo = np.sqrt(2) * scaling_filter / np.sum(scaling_filter)\n    dec_lo = rec_lo[::-1]\n\n    rec_hi = qmf(rec_lo)\n    dec_hi = rec_hi[::-1]\n\n    orth_filt_bank = (dec_lo, dec_hi, rec_lo, rec_hi)\n    return orth_filt_bank\n</code></pre>"},{"location":"ref/#pywt.pad","title":"<code>pad(x, pad_widths, mode)</code>","text":"<p>Extend a 1D signal using a given boundary mode.</p> <p>This function operates like :func:<code>numpy.pad</code> but supports all signal extension modes that can be used by PyWavelets discrete wavelet transforms.</p>"},{"location":"ref/#pywt.pad--parameters","title":"Parameters","text":"<p>x : ndarray     The array to pad pad_widths : {sequence, array_like, int}     Number of values padded to the edges of each axis.     <code>((before_1, after_1), \u2026 (before_N, after_N))</code> unique pad widths for     each axis. <code>((before, after),)</code> yields same before and after pad for     each axis. <code>(pad,)</code> or int is a shortcut for     <code>before = after = pad width</code> for all axes. mode : str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>.</p>"},{"location":"ref/#pywt.pad--returns","title":"Returns","text":"<p>pad : ndarray     Padded array of rank equal to array with shape increased according to     <code>pad_widths</code>.</p>"},{"location":"ref/#pywt.pad--notes","title":"Notes","text":"<p>The performance of padding in dimensions &gt; 1 may be substantially slower for modes <code>'smooth'</code> and <code>'antisymmetric'</code> as these modes are not supported efficiently by the underlying :func:<code>numpy.pad</code> function.</p> <p>Note that the behavior of the <code>'constant'</code> mode here follows the PyWavelets convention which is different from NumPy (it is equivalent to <code>mode='edge'</code> in :func:<code>numpy.pad</code>).</p> Source code in <code>pywt/_dwt.py</code> <pre><code>def pad(x, pad_widths, mode):\n    \"\"\"Extend a 1D signal using a given boundary mode.\n\n    This function operates like :func:`numpy.pad` but supports all signal\n    extension modes that can be used by PyWavelets discrete wavelet transforms.\n\n    Parameters\n    ----------\n    x : ndarray\n        The array to pad\n    pad_widths : {sequence, array_like, int}\n        Number of values padded to the edges of each axis.\n        ``((before_1, after_1), \u2026 (before_N, after_N))`` unique pad widths for\n        each axis. ``((before, after),)`` yields same before and after pad for\n        each axis. ``(pad,)`` or int is a shortcut for\n        ``before = after = pad width`` for all axes.\n    mode : str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n\n    Returns\n    -------\n    pad : ndarray\n        Padded array of rank equal to array with shape increased according to\n        ``pad_widths``.\n\n    Notes\n    -----\n    The performance of padding in dimensions &gt; 1 may be substantially slower\n    for modes ``'smooth'`` and ``'antisymmetric'`` as these modes are not\n    supported efficiently by the underlying :func:`numpy.pad` function.\n\n    Note that the behavior of the ``'constant'`` mode here follows the\n    PyWavelets convention which is different from NumPy (it is equivalent to\n    ``mode='edge'`` in :func:`numpy.pad`).\n    \"\"\"\n    x = np.asanyarray(x)\n\n    # process pad_widths exactly as in numpy.pad\n    pad_widths = np.array(pad_widths)\n    pad_widths = np.round(pad_widths).astype(np.intp, copy=False)\n    if pad_widths.min() &lt; 0:\n        raise ValueError(\"pad_widths must be &gt; 0\")\n    pad_widths = np.broadcast_to(pad_widths, (x.ndim, 2)).tolist()\n\n    if mode in ['symmetric', 'reflect']:\n        xp = np.pad(x, pad_widths, mode=mode)\n    elif mode in ['periodic', 'periodization']:\n        if mode == 'periodization':\n            # Promote odd-sized dimensions to even length by duplicating the\n            # last value.\n            edge_pad_widths = [(0, x.shape[ax] % 2)\n                               for ax in range(x.ndim)]\n            x = np.pad(x, edge_pad_widths, mode='edge')\n        xp = np.pad(x, pad_widths, mode='wrap')\n    elif mode == 'zero':\n        xp = np.pad(x, pad_widths, mode='constant', constant_values=0)\n    elif mode == 'constant':\n        xp = np.pad(x, pad_widths, mode='edge')\n    elif mode == 'smooth':\n        def pad_smooth(vector, pad_width, iaxis, kwargs):\n            # smooth extension to left\n            left = vector[pad_width[0]]\n            slope_left = (left - vector[pad_width[0] + 1])\n            vector[:pad_width[0]] = \\\n                left + np.arange(pad_width[0], 0, -1) * slope_left\n\n            # smooth extension to right\n            right = vector[-pad_width[1] - 1]\n            slope_right = (right - vector[-pad_width[1] - 2])\n            vector[-pad_width[1]:] = \\\n                right + np.arange(1, pad_width[1] + 1) * slope_right\n            return vector\n        xp = np.pad(x, pad_widths, pad_smooth)\n    elif mode == 'antisymmetric':\n        def pad_antisymmetric(vector, pad_width, iaxis, kwargs):\n            # smooth extension to left\n            # implement by flipping portions symmetric padding\n            npad_l, npad_r = pad_width\n            vsize_nonpad = vector.size - npad_l - npad_r\n            # Note: must modify vector in-place\n            vector[:] = np.pad(vector[pad_width[0]:-pad_width[-1]],\n                               pad_width, mode='symmetric')\n            vp = vector\n            r_edge = npad_l + vsize_nonpad - 1\n            l_edge = npad_l\n            # width of each reflected segment\n            seg_width = vsize_nonpad\n            # flip reflected segments on the right of the original signal\n            n = 1\n            while r_edge &lt;= vp.size:\n                segment_slice = slice(r_edge + 1,\n                                      min(r_edge + 1 + seg_width, vp.size))\n                if n % 2:\n                    vp[segment_slice] *= -1\n                r_edge += seg_width\n                n += 1\n\n            # flip reflected segments on the left of the original signal\n            n = 1\n            while l_edge &gt;= 0:\n                segment_slice = slice(max(0, l_edge - seg_width), l_edge)\n                if n % 2:\n                    vp[segment_slice] *= -1\n                l_edge -= seg_width\n                n += 1\n            return vector\n        xp = np.pad(x, pad_widths, pad_antisymmetric)\n    elif mode == 'antireflect':\n        xp = np.pad(x, pad_widths, mode='reflect', reflect_type='odd')\n    else:\n        raise ValueError(\n            f\"unsupported mode: {mode}. The supported modes are {Modes.modes}\")\n    return xp\n</code></pre>"},{"location":"ref/#pywt.qmf","title":"<code>qmf(filt)</code>","text":"<p>Returns the Quadrature Mirror Filter(QMF).</p> <p>The magnitude response of QMF is mirror image about <code>pi/2</code> of that of the input filter.</p>"},{"location":"ref/#pywt.qmf--parameters","title":"Parameters","text":"<p>filt : array_like     Input filter for which QMF needs to be computed.</p>"},{"location":"ref/#pywt.qmf--returns","title":"Returns","text":"<p>qm_filter : ndarray     Quadrature mirror of the input filter.</p> Source code in <code>pywt/_functions.py</code> <pre><code>def qmf(filt):\n    \"\"\"\n    Returns the Quadrature Mirror Filter(QMF).\n\n    The magnitude response of QMF is mirror image about `pi/2` of that of the\n    input filter.\n\n    Parameters\n    ----------\n    filt : array_like\n        Input filter for which QMF needs to be computed.\n\n    Returns\n    -------\n    qm_filter : ndarray\n        Quadrature mirror of the input filter.\n\n    \"\"\"\n    qm_filter = np.array(filt)[::-1]\n    qm_filter[1::2] = -qm_filter[1::2]\n    return qm_filter\n</code></pre>"},{"location":"ref/#pywt.ravel_coeffs","title":"<code>ravel_coeffs(coeffs, axes=None)</code>","text":"<p>Ravel a set of multilevel wavelet coefficients into a single 1D array.</p>"},{"location":"ref/#pywt.ravel_coeffs--parameters","title":"Parameters","text":"<p>coeffs : array-like     A list of multilevel wavelet coefficients as returned by     <code>wavedec</code>, <code>wavedec2</code> or <code>wavedecn</code>. This function is also     compatible with the output of <code>swt</code>, <code>swt2</code> and <code>swtn</code> if those     functions were called with <code>trim_approx=True</code>. axes : sequence of ints, optional     Axes over which the DWT that created <code>coeffs</code> was performed. The     default value of None corresponds to all axes.</p>"},{"location":"ref/#pywt.ravel_coeffs--returns","title":"Returns","text":"<p>coeff_arr : array-like     Wavelet transform coefficient array. All coefficients have been     concatenated into a single array. coeff_slices : list     List of slices corresponding to each coefficient. As a 2D example,     <code>coeff_arr[coeff_slices[1]['dd']]</code> would extract the first level     detail coefficients from <code>coeff_arr</code>. coeff_shapes : list     List of shapes corresponding to each coefficient. For example, in 2D,     <code>coeff_shapes[1]['dd']</code> would contain the original shape of the first     level detail coefficients array.</p>"},{"location":"ref/#pywt.ravel_coeffs--see-also","title":"See Also","text":"<p>unravel_coeffs : the inverse of ravel_coeffs</p>"},{"location":"ref/#pywt.ravel_coeffs--examples","title":"Examples","text":"<p>import pywt cam = pywt.data.camera() coeffs = pywt.wavedecn(cam, wavelet='db2', level=3) arr, coeff_slices, coeff_shapes = pywt.ravel_coeffs(coeffs)</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def ravel_coeffs(coeffs, axes=None):\n    \"\"\"Ravel a set of multilevel wavelet coefficients into a single 1D array.\n\n    Parameters\n    ----------\n    coeffs : array-like\n        A list of multilevel wavelet coefficients as returned by\n        ``wavedec``, ``wavedec2`` or ``wavedecn``. This function is also\n        compatible with the output of ``swt``, ``swt2`` and ``swtn`` if those\n        functions were called with ``trim_approx=True``.\n    axes : sequence of ints, optional\n        Axes over which the DWT that created ``coeffs`` was performed. The\n        default value of None corresponds to all axes.\n\n    Returns\n    -------\n    coeff_arr : array-like\n        Wavelet transform coefficient array. All coefficients have been\n        concatenated into a single array.\n    coeff_slices : list\n        List of slices corresponding to each coefficient. As a 2D example,\n        ``coeff_arr[coeff_slices[1]['dd']]`` would extract the first level\n        detail coefficients from ``coeff_arr``.\n    coeff_shapes : list\n        List of shapes corresponding to each coefficient. For example, in 2D,\n        ``coeff_shapes[1]['dd']`` would contain the original shape of the first\n        level detail coefficients array.\n\n    See Also\n    --------\n    unravel_coeffs : the inverse of ravel_coeffs\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; cam = pywt.data.camera()\n    &gt;&gt;&gt; coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n    &gt;&gt;&gt; arr, coeff_slices, coeff_shapes = pywt.ravel_coeffs(coeffs)\n\n    \"\"\"\n    coeffs, axes, ndim, ndim_transform = _prepare_coeffs_axes(coeffs, axes)\n\n    # initialize with the approximation coefficients.\n    a_coeffs = coeffs[0]\n    a_size = a_coeffs.size\n\n    if len(coeffs) == 1:\n        # only a single approximation coefficient array was found\n        return a_coeffs.ravel(), [slice(a_size), ], [a_coeffs.shape, ]\n\n    # preallocate output array\n    arr_size = wavedecn_size(coeffs)\n    coeff_arr = np.empty((arr_size, ), dtype=a_coeffs.dtype)\n\n    a_slice = slice(a_size)\n    coeff_arr[a_slice] = a_coeffs.ravel()\n\n    # initialize list of coefficient slices\n    coeff_slices = []\n    coeff_shapes = []\n    coeff_slices.append(a_slice)\n    coeff_shapes.append(coeffs[0].shape)\n\n    # loop over the detail coefficients, embedding them in coeff_arr\n    ds = coeffs[1:]\n    offset = a_size\n    for coeff_dict in ds:\n        # new dictionaries for detail coefficient slices and shapes\n        coeff_slices.append({})\n        coeff_shapes.append({})\n        if np.any([d is None for d in coeff_dict.values()]):\n            raise ValueError(\"coeffs_to_array does not support missing \"\n                             \"coefficients.\")\n        # sort to make sure key order is consistent across Python versions\n        keys = sorted(coeff_dict.keys())\n        for key in keys:\n            d = coeff_dict[key]\n            sl = slice(offset, offset + d.size)\n            offset += d.size\n            coeff_arr[sl] = d.ravel()\n            coeff_slices[-1][key] = sl\n            coeff_shapes[-1][key] = d.shape\n    return coeff_arr, coeff_slices, coeff_shapes\n</code></pre>"},{"location":"ref/#pywt.scale2frequency","title":"<code>scale2frequency(wavelet, scale, precision=8)</code>","text":"<p>Convert from CWT \"scale\" to normalized frequency.</p>"},{"location":"ref/#pywt.scale2frequency--parameters","title":"Parameters","text":"<p>wavelet : Wavelet instance or str     Wavelet to integrate.  If a string, should be the name of a wavelet. scale : scalar     The scale of the CWT. precision : int, optional     Precision that will be used for wavelet function approximation computed     with <code>wavelet.wavefun(level=precision)</code>.  Default is 8.</p>"},{"location":"ref/#pywt.scale2frequency--returns","title":"Returns","text":"<p>freq : scalar     Frequency normalized to the sampling frequency. In other words, for a     sampling interval of <code>dt</code> seconds, the normalized frequency of 1.0     corresponds to (<code>1/dt</code> Hz).</p> Source code in <code>pywt/_functions.py</code> <pre><code>def scale2frequency(wavelet, scale, precision=8):\n    \"\"\"Convert from CWT \"scale\" to normalized frequency.\n\n    Parameters\n    ----------\n    wavelet : Wavelet instance or str\n        Wavelet to integrate.  If a string, should be the name of a wavelet.\n    scale : scalar\n        The scale of the CWT.\n    precision : int, optional\n        Precision that will be used for wavelet function approximation computed\n        with ``wavelet.wavefun(level=precision)``.  Default is 8.\n\n    Returns\n    -------\n    freq : scalar\n        Frequency normalized to the sampling frequency. In other words, for a\n        sampling interval of `dt` seconds, the normalized frequency of 1.0\n        corresponds to (`1/dt` Hz).\n\n    \"\"\"\n    return central_frequency(wavelet, precision=precision) / scale\n</code></pre>"},{"location":"ref/#pywt.swt","title":"<code>swt(data, wavelet, level=None, start_level=0, axis=-1, trim_approx=False, norm=False)</code>","text":"<p>Multilevel 1D stationary wavelet transform.</p>"},{"location":"ref/#pywt.swt--parameters","title":"Parameters","text":"<p>data :     Input signal wavelet :     Wavelet to use (Wavelet object or name) level : int, optional     The number of decomposition steps to perform. start_level : int, optional     The level at which the decomposition will begin (it allows one to     skip a given number of transform steps and compute     coefficients starting from start_level) (default: 0) axis: int, optional     Axis over which to compute the SWT. If not given, the     last axis is used. trim_approx : bool, optional     If True, approximation coefficients at the final level are retained. norm : bool, optional     If True, transform is normalized so that the energy of the coefficients     will be equal to the energy of <code>data</code>. In other words,     <code>np.linalg.norm(data.ravel())</code> will equal the norm of the     concatenated transform coefficients when <code>trim_approx</code> is True.</p>"},{"location":"ref/#pywt.swt--returns","title":"Returns","text":"<p>coeffs : list     List of approximation and details coefficients pairs in order     similar to wavedec function::</p> <pre><code>    [(cAn, cDn), ..., (cA2, cD2), (cA1, cD1)]\n\nwhere n equals input parameter ``level``.\n\nIf ``start_level = m`` is given, then the beginning m steps are\nskipped::\n\n    [(cAm+n, cDm+n), ..., (cAm+1, cDm+1), (cAm, cDm)]\n\nIf ``trim_approx`` is ``True``, then the output list is exactly as in\n``pywt.wavedec``, where the first coefficient in the list is the\napproximation coefficient at the final level and the rest are the\ndetail coefficients::\n\n    [cAn, cDn, ..., cD2, cD1]\n</code></pre>"},{"location":"ref/#pywt.swt--notes","title":"Notes","text":"<p>The implementation here follows the \"algorithm a-trous\" and requires that the signal length along the transformed axis be a multiple of <code>2**level</code>. If this is not the case, the user should pad up to an appropriate size using a function such as <code>numpy.pad</code>.</p> <p>A primary benefit of this transform in comparison to its decimated counterpart (<code>pywt.wavedecn</code>), is that it is shift-invariant. This comes at cost of redundancy in the transform (the size of the output coefficients is larger than the input).</p> <p>When the following three conditions are true:</p> <pre><code>1. The wavelet is orthogonal\n2. ``swt`` is called with ``norm=True``\n3. ``swt`` is called with ``trim_approx=True``\n</code></pre> <p>the transform has the following additional properties that may be desirable in applications:</p> <pre><code>1. energy is conserved\n2. variance is partitioned across scales\n</code></pre> <p>When used with <code>norm=True</code>, this transform is closely related to the multiple-overlap DWT (MODWT) as popularized for time-series analysis, although the underlying implementation is slightly different from the one published in [1]_. Specifically, the implementation used here requires a signal that is a multiple of <code>2**level</code> in length.</p>"},{"location":"ref/#pywt.swt--references","title":"References","text":"<p>.. [1] DB Percival and AT Walden. Wavelet Methods for Time Series Analysis.     Cambridge University Press, 2000.</p> Source code in <code>pywt/_swt.py</code> <pre><code>def swt(data, wavelet, level=None, start_level=0, axis=-1,\n        trim_approx=False, norm=False):\n    \"\"\"\n    Multilevel 1D stationary wavelet transform.\n\n    Parameters\n    ----------\n    data :\n        Input signal\n    wavelet :\n        Wavelet to use (Wavelet object or name)\n    level : int, optional\n        The number of decomposition steps to perform.\n    start_level : int, optional\n        The level at which the decomposition will begin (it allows one to\n        skip a given number of transform steps and compute\n        coefficients starting from start_level) (default: 0)\n    axis: int, optional\n        Axis over which to compute the SWT. If not given, the\n        last axis is used.\n    trim_approx : bool, optional\n        If True, approximation coefficients at the final level are retained.\n    norm : bool, optional\n        If True, transform is normalized so that the energy of the coefficients\n        will be equal to the energy of ``data``. In other words,\n        ``np.linalg.norm(data.ravel())`` will equal the norm of the\n        concatenated transform coefficients when ``trim_approx`` is True.\n\n    Returns\n    -------\n    coeffs : list\n        List of approximation and details coefficients pairs in order\n        similar to wavedec function::\n\n            [(cAn, cDn), ..., (cA2, cD2), (cA1, cD1)]\n\n        where n equals input parameter ``level``.\n\n        If ``start_level = m`` is given, then the beginning m steps are\n        skipped::\n\n            [(cAm+n, cDm+n), ..., (cAm+1, cDm+1), (cAm, cDm)]\n\n        If ``trim_approx`` is ``True``, then the output list is exactly as in\n        ``pywt.wavedec``, where the first coefficient in the list is the\n        approximation coefficient at the final level and the rest are the\n        detail coefficients::\n\n            [cAn, cDn, ..., cD2, cD1]\n\n    Notes\n    -----\n    The implementation here follows the \"algorithm a-trous\" and requires that\n    the signal length along the transformed axis be a multiple of ``2**level``.\n    If this is not the case, the user should pad up to an appropriate size\n    using a function such as ``numpy.pad``.\n\n    A primary benefit of this transform in comparison to its decimated\n    counterpart (``pywt.wavedecn``), is that it is shift-invariant. This comes\n    at cost of redundancy in the transform (the size of the output coefficients\n    is larger than the input).\n\n    When the following three conditions are true:\n\n        1. The wavelet is orthogonal\n        2. ``swt`` is called with ``norm=True``\n        3. ``swt`` is called with ``trim_approx=True``\n\n    the transform has the following additional properties that may be\n    desirable in applications:\n\n        1. energy is conserved\n        2. variance is partitioned across scales\n\n    When used with ``norm=True``, this transform is closely related to the\n    multiple-overlap DWT (MODWT) as popularized for time-series analysis,\n    although the underlying implementation is slightly different from the one\n    published in [1]_. Specifically, the implementation used here requires a\n    signal that is a multiple of ``2**level`` in length.\n\n    References\n    ----------\n    .. [1] DB Percival and AT Walden. Wavelet Methods for Time Series Analysis.\n        Cambridge University Press, 2000.\n    \"\"\"\n\n    if not _have_c99_complex and np.iscomplexobj(data):\n        data = np.asarray(data)\n        kwargs = {\"wavelet\": wavelet, \"level\": level, \"start_level\": start_level,\n                      \"trim_approx\": trim_approx, \"axis\": axis, \"norm\": norm}\n        coeffs_real = swt(data.real, **kwargs)\n        coeffs_imag = swt(data.imag, **kwargs)\n        if not trim_approx:\n            coeffs_cplx = []\n            for (cA_r, cD_r), (cA_i, cD_i) in zip(coeffs_real, coeffs_imag):\n                coeffs_cplx.append((cA_r + 1j*cA_i, cD_r + 1j*cD_i))\n        else:\n            coeffs_cplx = [cr + 1j*ci\n                           for (cr, ci) in zip(coeffs_real, coeffs_imag)]\n        return coeffs_cplx\n\n    # accept array_like input; make a copy to ensure a contiguous array\n    dt = _check_dtype(data)\n    data = np.array(data, dtype=dt)\n\n    wavelet = _as_wavelet(wavelet)\n    if norm:\n        if not wavelet.orthogonal:\n            warnings.warn(\n                \"norm=True, but the wavelet is not orthogonal: \\n\"\n                \"\\tThe conditions for energy preservation are not satisfied.\")\n        wavelet = _rescale_wavelet_filterbank(wavelet, 1/np.sqrt(2))\n\n    if axis &lt; 0:\n        axis = axis + data.ndim\n    if not 0 &lt;= axis &lt; data.ndim:\n        raise AxisError(\"Axis greater than data dimensions\")\n\n    if level is None:\n        level = swt_max_level(data.shape[axis])\n\n    if data.ndim == 1:\n        ret = _swt(data, wavelet, level, start_level, trim_approx)\n    else:\n        ret = _swt_axis(data, wavelet, level, start_level, axis, trim_approx)\n    return ret\n</code></pre>"},{"location":"ref/#pywt.swt2","title":"<code>swt2(data, wavelet, level, start_level=0, axes=(-2, -1), trim_approx=False, norm=False)</code>","text":"<p>Multilevel 2D stationary wavelet transform.</p>"},{"location":"ref/#pywt.swt2--parameters","title":"Parameters","text":"<p>data : array_like     2D array with input data wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a tuple of wavelets to apply per     axis in <code>axes</code>. level : int     The number of decomposition steps to perform. start_level : int, optional     The level at which the decomposition will start (default: 0) axes : 2-tuple of ints, optional     Axes over which to compute the SWT. Repeated elements are not allowed. trim_approx : bool, optional     If True, approximation coefficients at the final level are retained. norm : bool, optional     If True, transform is normalized so that the energy of the coefficients     will be equal to the energy of <code>data</code>. In other words,     <code>np.linalg.norm(data.ravel())</code> will equal the norm of the     concatenated transform coefficients when <code>trim_approx</code> is True.</p>"},{"location":"ref/#pywt.swt2--returns","title":"Returns","text":"<p>coeffs : list     Approximation and details coefficients (for <code>start_level = m</code>).     If <code>trim_approx</code> is <code>False</code>, approximation coefficients are     retained for all levels::</p> <pre><code>    [\n        (cA_m+level,\n            (cH_m+level, cV_m+level, cD_m+level)\n        ),\n        ...,\n        (cA_m+1,\n            (cH_m+1, cV_m+1, cD_m+1)\n        ),\n        (cA_m,\n            (cH_m, cV_m, cD_m)\n        )\n    ]\n\nwhere cA is approximation, cH is horizontal details, cV is\nvertical details, cD is diagonal details and m is ``start_level``.\n\nIf ``trim_approx`` is ``True``, approximation coefficients are only\nretained at the final level of decomposition. This matches the format\nused by ``pywt.wavedec2``::\n\n    [\n        cA_m+level,\n        (cH_m+level, cV_m+level, cD_m+level),\n        ...,\n        (cH_m+1, cV_m+1, cD_m+1),\n        (cH_m, cV_m, cD_m),\n    ]\n</code></pre>"},{"location":"ref/#pywt.swt2--notes","title":"Notes","text":"<p>The implementation here follows the \"algorithm a-trous\" and requires that the signal length along the transformed axes be a multiple of <code>2**level</code>. If this is not the case, the user should pad up to an appropriate size using a function such as <code>numpy.pad</code>.</p> <p>A primary benefit of this transform in comparison to its decimated counterpart (<code>pywt.wavedecn</code>), is that it is shift-invariant. This comes at cost of redundancy in the transform (the size of the output coefficients is larger than the input).</p> <p>When the following three conditions are true:</p> <pre><code>1. The wavelet is orthogonal\n2. ``swt2`` is called with ``norm=True``\n3. ``swt2`` is called with ``trim_approx=True``\n</code></pre> <p>the transform has the following additional properties that may be desirable in applications:</p> <pre><code>1. energy is conserved\n2. variance is partitioned across scales\n</code></pre> Source code in <code>pywt/_swt.py</code> <pre><code>def swt2(data, wavelet, level, start_level=0, axes=(-2, -1),\n         trim_approx=False, norm=False):\n    \"\"\"\n    Multilevel 2D stationary wavelet transform.\n\n    Parameters\n    ----------\n    data : array_like\n        2D array with input data\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a tuple of wavelets to apply per\n        axis in ``axes``.\n    level : int\n        The number of decomposition steps to perform.\n    start_level : int, optional\n        The level at which the decomposition will start (default: 0)\n    axes : 2-tuple of ints, optional\n        Axes over which to compute the SWT. Repeated elements are not allowed.\n    trim_approx : bool, optional\n        If True, approximation coefficients at the final level are retained.\n    norm : bool, optional\n        If True, transform is normalized so that the energy of the coefficients\n        will be equal to the energy of ``data``. In other words,\n        ``np.linalg.norm(data.ravel())`` will equal the norm of the\n        concatenated transform coefficients when ``trim_approx`` is True.\n\n    Returns\n    -------\n    coeffs : list\n        Approximation and details coefficients (for ``start_level = m``).\n        If ``trim_approx`` is ``False``, approximation coefficients are\n        retained for all levels::\n\n            [\n                (cA_m+level,\n                    (cH_m+level, cV_m+level, cD_m+level)\n                ),\n                ...,\n                (cA_m+1,\n                    (cH_m+1, cV_m+1, cD_m+1)\n                ),\n                (cA_m,\n                    (cH_m, cV_m, cD_m)\n                )\n            ]\n\n        where cA is approximation, cH is horizontal details, cV is\n        vertical details, cD is diagonal details and m is ``start_level``.\n\n        If ``trim_approx`` is ``True``, approximation coefficients are only\n        retained at the final level of decomposition. This matches the format\n        used by ``pywt.wavedec2``::\n\n            [\n                cA_m+level,\n                (cH_m+level, cV_m+level, cD_m+level),\n                ...,\n                (cH_m+1, cV_m+1, cD_m+1),\n                (cH_m, cV_m, cD_m),\n            ]\n\n    Notes\n    -----\n    The implementation here follows the \"algorithm a-trous\" and requires that\n    the signal length along the transformed axes be a multiple of ``2**level``.\n    If this is not the case, the user should pad up to an appropriate size\n    using a function such as ``numpy.pad``.\n\n    A primary benefit of this transform in comparison to its decimated\n    counterpart (``pywt.wavedecn``), is that it is shift-invariant. This comes\n    at cost of redundancy in the transform (the size of the output coefficients\n    is larger than the input).\n\n    When the following three conditions are true:\n\n        1. The wavelet is orthogonal\n        2. ``swt2`` is called with ``norm=True``\n        3. ``swt2`` is called with ``trim_approx=True``\n\n    the transform has the following additional properties that may be\n    desirable in applications:\n\n        1. energy is conserved\n        2. variance is partitioned across scales\n\n    \"\"\"\n    axes = tuple(axes)\n    data = np.asarray(data)\n    if len(axes) != 2:\n        raise ValueError(\"Expected 2 axes\")\n    if len(axes) != len(set(axes)):\n        raise ValueError(\"The axes passed to swt2 must be unique.\")\n    if data.ndim &lt; len(np.unique(axes)):\n        raise ValueError(\"Input array has fewer dimensions than the specified \"\n                         \"axes\")\n\n    coefs = swtn(data, wavelet, level, start_level, axes, trim_approx, norm)\n    ret = []\n    if trim_approx:\n        ret.append(coefs[0])\n        coefs = coefs[1:]\n    for c in coefs:\n        if trim_approx:\n            ret.append((c['da'], c['ad'], c['dd']))\n        else:\n            ret.append((c['aa'], (c['da'], c['ad'], c['dd'])))\n    return ret\n</code></pre>"},{"location":"ref/#pywt.swtn","title":"<code>swtn(data, wavelet, level, start_level=0, axes=None, trim_approx=False, norm=False)</code>","text":"<p>n-dimensional stationary wavelet transform.</p>"},{"location":"ref/#pywt.swtn--parameters","title":"Parameters","text":"<p>data : array_like     n-dimensional array with input data. wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple of wavelets to apply per     axis in <code>axes</code>. level : int     The number of decomposition steps to perform. start_level : int, optional     The level at which the decomposition will start (default: 0) axes : sequence of ints, optional     Axes over which to compute the SWT. A value of <code>None</code> (the     default) selects all axes. Axes may not be repeated. trim_approx : bool, optional     If True, approximation coefficients at the final level are retained. norm : bool, optional     If True, transform is normalized so that the energy of the coefficients     will be equal to the energy of <code>data</code>. In other words,     <code>np.linalg.norm(data.ravel())</code> will equal the norm of the     concatenated transform coefficients when <code>trim_approx</code> is True.</p>"},{"location":"ref/#pywt.swtn--returns","title":"Returns","text":"<p>[{coeffs_level_n}, ..., {coeffs_level_1}]: list of dict     Results for each level are arranged in a dictionary, where the key     specifies the transform type on each dimension and value is a     n-dimensional coefficients array.</p> <pre><code>For example, for a 2D case the result at a given level will look\nsomething like this::\n\n    {'aa': &lt;coeffs&gt;  # A(LL) - approx. on 1st dim, approx. on 2nd dim\n     'ad': &lt;coeffs&gt;  # V(LH) - approx. on 1st dim, det. on 2nd dim\n     'da': &lt;coeffs&gt;  # H(HL) - det. on 1st dim, approx. on 2nd dim\n     'dd': &lt;coeffs&gt;  # D(HH) - det. on 1st dim, det. on 2nd dim\n    }\n\nFor user-specified ``axes``, the order of the characters in the\ndictionary keys map to the specified ``axes``.\n\nIf ``trim_approx`` is ``True``, the first element of the list contains\nthe array of approximation coefficients from the final level of\ndecomposition, while the remaining coefficient dictionaries contain\nonly detail coefficients. This matches the behavior of `pywt.wavedecn`.\n</code></pre>"},{"location":"ref/#pywt.swtn--notes","title":"Notes","text":"<p>The implementation here follows the \"algorithm a-trous\" and requires that the signal length along the transformed axes be a multiple of <code>2**level</code>. If this is not the case, the user should pad up to an appropriate size using a function such as <code>numpy.pad</code>.</p> <p>A primary benefit of this transform in comparison to its decimated counterpart (<code>pywt.wavedecn</code>), is that it is shift-invariant. This comes at cost of redundancy in the transform (the size of the output coefficients is larger than the input).</p> <p>When the following three conditions are true:</p> <pre><code>1. The wavelet is orthogonal\n2. ``swtn`` is called with ``norm=True``\n3. ``swtn`` is called with ``trim_approx=True``\n</code></pre> <p>the transform has the following additional properties that may be desirable in applications:</p> <pre><code>1. energy is conserved\n2. variance is partitioned across scales\n</code></pre> Source code in <code>pywt/_swt.py</code> <pre><code>def swtn(data, wavelet, level, start_level=0, axes=None, trim_approx=False,\n         norm=False):\n    \"\"\"\n    n-dimensional stationary wavelet transform.\n\n    Parameters\n    ----------\n    data : array_like\n        n-dimensional array with input data.\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple of wavelets to apply per\n        axis in ``axes``.\n    level : int\n        The number of decomposition steps to perform.\n    start_level : int, optional\n        The level at which the decomposition will start (default: 0)\n    axes : sequence of ints, optional\n        Axes over which to compute the SWT. A value of ``None`` (the\n        default) selects all axes. Axes may not be repeated.\n    trim_approx : bool, optional\n        If True, approximation coefficients at the final level are retained.\n    norm : bool, optional\n        If True, transform is normalized so that the energy of the coefficients\n        will be equal to the energy of ``data``. In other words,\n        ``np.linalg.norm(data.ravel())`` will equal the norm of the\n        concatenated transform coefficients when ``trim_approx`` is True.\n\n    Returns\n    -------\n    [{coeffs_level_n}, ..., {coeffs_level_1}]: list of dict\n        Results for each level are arranged in a dictionary, where the key\n        specifies the transform type on each dimension and value is a\n        n-dimensional coefficients array.\n\n        For example, for a 2D case the result at a given level will look\n        something like this::\n\n            {'aa': &lt;coeffs&gt;  # A(LL) - approx. on 1st dim, approx. on 2nd dim\n             'ad': &lt;coeffs&gt;  # V(LH) - approx. on 1st dim, det. on 2nd dim\n             'da': &lt;coeffs&gt;  # H(HL) - det. on 1st dim, approx. on 2nd dim\n             'dd': &lt;coeffs&gt;  # D(HH) - det. on 1st dim, det. on 2nd dim\n            }\n\n        For user-specified ``axes``, the order of the characters in the\n        dictionary keys map to the specified ``axes``.\n\n        If ``trim_approx`` is ``True``, the first element of the list contains\n        the array of approximation coefficients from the final level of\n        decomposition, while the remaining coefficient dictionaries contain\n        only detail coefficients. This matches the behavior of `pywt.wavedecn`.\n\n    Notes\n    -----\n    The implementation here follows the \"algorithm a-trous\" and requires that\n    the signal length along the transformed axes be a multiple of ``2**level``.\n    If this is not the case, the user should pad up to an appropriate size\n    using a function such as ``numpy.pad``.\n\n    A primary benefit of this transform in comparison to its decimated\n    counterpart (``pywt.wavedecn``), is that it is shift-invariant. This comes\n    at cost of redundancy in the transform (the size of the output coefficients\n    is larger than the input).\n\n    When the following three conditions are true:\n\n        1. The wavelet is orthogonal\n        2. ``swtn`` is called with ``norm=True``\n        3. ``swtn`` is called with ``trim_approx=True``\n\n    the transform has the following additional properties that may be\n    desirable in applications:\n\n        1. energy is conserved\n        2. variance is partitioned across scales\n\n    \"\"\"\n    data = np.asarray(data)\n    if not _have_c99_complex and np.iscomplexobj(data):\n        kwargs = {\"wavelet\": wavelet, \"level\": level, \"start_level\": start_level,\n                      \"trim_approx\": trim_approx, \"axes\": axes, \"norm\": norm}\n        real = swtn(data.real, **kwargs)\n        imag = swtn(data.imag, **kwargs)\n        if trim_approx:\n            cplx = [real[0] + 1j * imag[0]]\n            offset = 1\n        else:\n            cplx = []\n            offset = 0\n        for rdict, idict in zip(real[offset:], imag[offset:]):\n            cplx.append(\n                {k: rdict[k] + 1j * idict[k] for k in rdict})\n        return cplx\n\n    if data.dtype == np.dtype('object'):\n        raise TypeError(\"Input must be a numeric array-like\")\n    if data.ndim &lt; 1:\n        raise ValueError(\"Input data must be at least 1D\")\n\n    if axes is None:\n        axes = range(data.ndim)\n    axes = [a + data.ndim if a &lt; 0 else a for a in axes]\n    if any(a &lt; 0 or a &gt;= data.ndim for a in axes):\n        raise AxisError(\"Axis greater than data dimensions\")\n    if len(axes) != len(set(axes)):\n        raise ValueError(\"The axes passed to swtn must be unique.\")\n    num_axes = len(axes)\n\n    wavelets = _wavelets_per_axis(wavelet, axes)\n    if norm:\n        if not np.all([wav.orthogonal for wav in wavelets]):\n            warnings.warn(\n                \"norm=True, but the wavelets used are not orthogonal: \\n\"\n                \"\\tThe conditions for energy preservation are not satisfied.\")\n        wavelets = [_rescale_wavelet_filterbank(wav, 1/np.sqrt(2))\n                    for wav in wavelets]\n    ret = []\n    for i in range(start_level, start_level + level):\n        coeffs = [('', data)]\n        for axis, wavelet in zip(axes, wavelets):\n            new_coeffs = []\n            for subband, x in coeffs:\n                cA, cD = _swt_axis(x, wavelet, level=1, start_level=i,\n                                   axis=axis)[0]\n                new_coeffs.extend([(subband + 'a', cA),\n                                   (subband + 'd', cD)])\n            coeffs = new_coeffs\n\n        coeffs = dict(coeffs)\n        ret.append(coeffs)\n\n        # data for the next level is the approximation coeffs from this level\n        data = coeffs['a' * num_axes]\n        if trim_approx:\n            coeffs.pop('a' * num_axes)\n    if trim_approx:\n        ret.append(data)\n    ret.reverse()\n    return ret\n</code></pre>"},{"location":"ref/#pywt.threshold","title":"<code>threshold(data, value, mode='soft', substitute=0)</code>","text":"<p>Thresholds the input data depending on the mode argument.</p> <p>In <code>soft</code> thresholding [1]_, data values with absolute value less than <code>param</code> are replaced with <code>substitute</code>. Data values with absolute value greater or equal to the thresholding value are shrunk toward zero by <code>value</code>.  In other words, the new value is <code>data/np.abs(data) * np.maximum(np.abs(data) - value, 0)</code>.</p> <p>In <code>hard</code> thresholding, the data values where their absolute value is less than the value param are replaced with <code>substitute</code>. Data values with absolute value greater or equal to the thresholding value stay untouched.</p> <p><code>garrote</code> corresponds to the Non-negative garrote threshold [2], [3]. It is intermediate between <code>hard</code> and <code>soft</code> thresholding.  It behaves like soft thresholding for small data values and approaches hard thresholding for large data values.</p> <p>In <code>greater</code> thresholding, the data is replaced with <code>substitute</code> where data is below the thresholding value. Greater data values pass untouched.</p> <p>In <code>less</code> thresholding, the data is replaced with <code>substitute</code> where data is above the thresholding value. Lesser data values pass untouched.</p> <p>Both <code>hard</code> and <code>soft</code> thresholding also support complex-valued data.</p>"},{"location":"ref/#pywt.threshold--parameters","title":"Parameters","text":"<p>data : array_like     Numeric data. value : scalar     Thresholding value. mode : {'soft', 'hard', 'garrote', 'greater', 'less'}     Decides the type of thresholding to be applied on input data. Default     is 'soft'. substitute : float, optional     Substitute value (default: 0).</p>"},{"location":"ref/#pywt.threshold--returns","title":"Returns","text":"<p>output : array     Thresholded array.</p>"},{"location":"ref/#pywt.threshold--see-also","title":"See Also","text":"<p>threshold_firm</p>"},{"location":"ref/#pywt.threshold--references","title":"References","text":"<p>.. [1] D.L. Donoho and I.M. Johnstone. Ideal Spatial Adaptation via     Wavelet Shrinkage. Biometrika. Vol. 81, No. 3, pp.425-455, 1994.     DOI:10.1093/biomet/81.3.425 .. [2] L. Breiman. Better Subset Regression Using the Nonnegative Garrote.     Technometrics, Vol. 37, pp. 373-384, 1995.     DOI:10.2307/1269730 .. [3] H-Y. Gao.  Wavelet Shrinkage Denoising Using the Non-Negative     Garrote.  Journal of Computational and Graphical Statistics Vol. 7,     No. 4, pp.469-488. 1998.     DOI:10.1080/10618600.1998.10474789</p>"},{"location":"ref/#pywt.threshold--examples","title":"Examples","text":"<p>import numpy as np import pywt data = np.linspace(1, 4, 7) data array([ 1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ]) pywt.threshold(data, 2, 'soft') array([ 0. ,  0. ,  0. ,  0.5,  1. ,  1.5,  2. ]) pywt.threshold(data, 2, 'hard') array([ 0. ,  0. ,  2. ,  2.5,  3. ,  3.5,  4. ]) pywt.threshold(data, 2, 'garrote') array([ 0.        ,  0.        ,  0.        ,  0.9       ,  1.66666667,         2.35714286,  3.        ]) pywt.threshold(data, 2, 'greater') array([ 0. ,  0. ,  2. ,  2.5,  3. ,  3.5,  4. ]) pywt.threshold(data, 2, 'less') array([ 1. ,  1.5,  2. ,  0. ,  0. ,  0. ,  0. ])</p> Source code in <code>pywt/_thresholding.py</code> <pre><code>def threshold(data, value, mode='soft', substitute=0):\n    \"\"\"\n    Thresholds the input data depending on the mode argument.\n\n    In ``soft`` thresholding [1]_, data values with absolute value less than\n    `param` are replaced with `substitute`. Data values with absolute value\n    greater or equal to the thresholding value are shrunk toward zero\n    by `value`.  In other words, the new value is\n    ``data/np.abs(data) * np.maximum(np.abs(data) - value, 0)``.\n\n    In ``hard`` thresholding, the data values where their absolute value is\n    less than the value param are replaced with `substitute`. Data values with\n    absolute value greater or equal to the thresholding value stay untouched.\n\n    ``garrote`` corresponds to the Non-negative garrote threshold [2]_, [3]_.\n    It is intermediate between ``hard`` and ``soft`` thresholding.  It behaves\n    like soft thresholding for small data values and approaches hard\n    thresholding for large data values.\n\n    In ``greater`` thresholding, the data is replaced with `substitute` where\n    data is below the thresholding value. Greater data values pass untouched.\n\n    In ``less`` thresholding, the data is replaced with `substitute` where data\n    is above the thresholding value. Lesser data values pass untouched.\n\n    Both ``hard`` and ``soft`` thresholding also support complex-valued data.\n\n    Parameters\n    ----------\n    data : array_like\n        Numeric data.\n    value : scalar\n        Thresholding value.\n    mode : {'soft', 'hard', 'garrote', 'greater', 'less'}\n        Decides the type of thresholding to be applied on input data. Default\n        is 'soft'.\n    substitute : float, optional\n        Substitute value (default: 0).\n\n    Returns\n    -------\n    output : array\n        Thresholded array.\n\n    See Also\n    --------\n    threshold_firm\n\n    References\n    ----------\n    .. [1] D.L. Donoho and I.M. Johnstone. Ideal Spatial Adaptation via\n        Wavelet Shrinkage. Biometrika. Vol. 81, No. 3, pp.425-455, 1994.\n        DOI:10.1093/biomet/81.3.425\n    .. [2] L. Breiman. Better Subset Regression Using the Nonnegative Garrote.\n        Technometrics, Vol. 37, pp. 373-384, 1995.\n        DOI:10.2307/1269730\n    .. [3] H-Y. Gao.  Wavelet Shrinkage Denoising Using the Non-Negative\n        Garrote.  Journal of Computational and Graphical Statistics Vol. 7,\n        No. 4, pp.469-488. 1998.\n        DOI:10.1080/10618600.1998.10474789\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; data = np.linspace(1, 4, 7)\n    &gt;&gt;&gt; data\n    array([ 1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ])\n    &gt;&gt;&gt; pywt.threshold(data, 2, 'soft')\n    array([ 0. ,  0. ,  0. ,  0.5,  1. ,  1.5,  2. ])\n    &gt;&gt;&gt; pywt.threshold(data, 2, 'hard')\n    array([ 0. ,  0. ,  2. ,  2.5,  3. ,  3.5,  4. ])\n    &gt;&gt;&gt; pywt.threshold(data, 2, 'garrote')\n    array([ 0.        ,  0.        ,  0.        ,  0.9       ,  1.66666667,\n            2.35714286,  3.        ])\n    &gt;&gt;&gt; pywt.threshold(data, 2, 'greater')\n    array([ 0. ,  0. ,  2. ,  2.5,  3. ,  3.5,  4. ])\n    &gt;&gt;&gt; pywt.threshold(data, 2, 'less')\n    array([ 1. ,  1.5,  2. ,  0. ,  0. ,  0. ,  0. ])\n\n    \"\"\"\n\n    try:\n        return thresholding_options[mode](data, value, substitute)\n    except KeyError:\n        # Make sure error is always identical by sorting keys\n        keys = (f\"'{key}'\" for key in\n                sorted(thresholding_options.keys()))\n        raise ValueError(\"The mode parameter only takes values from: {}.\"\n                         .format(', '.join(keys)))\n</code></pre>"},{"location":"ref/#pywt.threshold_firm","title":"<code>threshold_firm(data, value_low, value_high)</code>","text":"<p>Firm threshold.</p> <p>The approach is intermediate between soft and hard thresholding [1]_. It behaves the same as soft-thresholding for values below <code>value_low</code> and the same as hard-thresholding for values above <code>thresh_high</code>.  For intermediate values, the thresholded value is in between that corresponding to soft or hard thresholding.</p>"},{"location":"ref/#pywt.threshold_firm--parameters","title":"Parameters","text":"<p>data : array-like     The data to threshold.  This can be either real or complex-valued. value_low : float     Any values smaller then <code>value_low</code> will be set to zero. value_high : float     Any values larger than <code>value_high</code> will not be modified.</p>"},{"location":"ref/#pywt.threshold_firm--notes","title":"Notes","text":"<p>This thresholding technique is also known as semi-soft thresholding [2]_.</p> <p>For each value, <code>x</code>, in <code>data</code>. This function computes::</p> <pre><code>if np.abs(x) &lt;= value_low:\n    return 0\nelif np.abs(x) &gt; value_high:\n    return x\nelif value_low &lt; np.abs(x) and np.abs(x) &lt;= value_high:\n    return x * value_high * (1 - value_low/x)/(value_high - value_low)\n</code></pre> <p><code>firm</code> is a continuous function (like soft thresholding), but is unbiased for large values (like hard thresholding).</p> <p>If <code>value_high == value_low</code> this function becomes hard-thresholding. If <code>value_high</code> is infinity, this function becomes soft-thresholding.</p>"},{"location":"ref/#pywt.threshold_firm--returns","title":"Returns","text":"<p>val_new : array-like     The values after firm thresholding at the specified thresholds.</p>"},{"location":"ref/#pywt.threshold_firm--see-also","title":"See Also","text":"<p>threshold</p>"},{"location":"ref/#pywt.threshold_firm--references","title":"References","text":"<p>.. [1] H.-Y. Gao and A.G. Bruce. Waveshrink with firm shrinkage.     Statistica Sinica, Vol. 7, pp. 855-874, 1997. .. [2] A. Bruce and H-Y. Gao. WaveShrink: Shrinkage Functions and     Thresholds. Proc. SPIE 2569, Wavelet Applications in Signal and     Image Processing III, 1995.     DOI:10.1117/12.217582</p> Source code in <code>pywt/_thresholding.py</code> <pre><code>def threshold_firm(data, value_low, value_high):\n    \"\"\"Firm threshold.\n\n    The approach is intermediate between soft and hard thresholding [1]_. It\n    behaves the same as soft-thresholding for values below `value_low` and\n    the same as hard-thresholding for values above `thresh_high`.  For\n    intermediate values, the thresholded value is in between that corresponding\n    to soft or hard thresholding.\n\n    Parameters\n    ----------\n    data : array-like\n        The data to threshold.  This can be either real or complex-valued.\n    value_low : float\n        Any values smaller then `value_low` will be set to zero.\n    value_high : float\n        Any values larger than `value_high` will not be modified.\n\n    Notes\n    -----\n    This thresholding technique is also known as semi-soft thresholding [2]_.\n\n    For each value, `x`, in `data`. This function computes::\n\n        if np.abs(x) &lt;= value_low:\n            return 0\n        elif np.abs(x) &gt; value_high:\n            return x\n        elif value_low &lt; np.abs(x) and np.abs(x) &lt;= value_high:\n            return x * value_high * (1 - value_low/x)/(value_high - value_low)\n\n    ``firm`` is a continuous function (like soft thresholding), but is\n    unbiased for large values (like hard thresholding).\n\n    If ``value_high == value_low`` this function becomes hard-thresholding.\n    If ``value_high`` is infinity, this function becomes soft-thresholding.\n\n    Returns\n    -------\n    val_new : array-like\n        The values after firm thresholding at the specified thresholds.\n\n    See Also\n    --------\n    threshold\n\n    References\n    ----------\n    .. [1] H.-Y. Gao and A.G. Bruce. Waveshrink with firm shrinkage.\n        Statistica Sinica, Vol. 7, pp. 855-874, 1997.\n    .. [2] A. Bruce and H-Y. Gao. WaveShrink: Shrinkage Functions and\n        Thresholds. Proc. SPIE 2569, Wavelet Applications in Signal and\n        Image Processing III, 1995.\n        DOI:10.1117/12.217582\n    \"\"\"\n\n    if value_low &lt; 0:\n        raise ValueError(\"value_low must be non-negative.\")\n\n    if value_high &lt; value_low:\n        raise ValueError(\n            \"value_high must be greater than or equal to value_low.\")\n\n    data = np.asarray(data)\n    magnitude = np.absolute(data)\n    with np.errstate(divide='ignore'):\n        # divide by zero okay as np.inf values get clipped, so ignore warning.\n        vdiff = value_high - value_low\n        thresholded = value_high * (1 - value_low/magnitude) / vdiff\n        thresholded.clip(min=0, max=None, out=thresholded)\n        thresholded = data * thresholded\n\n    # restore hard-thresholding behavior for values &gt; value_high\n    large_vals = np.where(magnitude &gt; value_high)\n    if np.any(large_vals[0]):\n        thresholded[large_vals] = data[large_vals]\n    return thresholded\n</code></pre>"},{"location":"ref/#pywt.unravel_coeffs","title":"<code>unravel_coeffs(arr, coeff_slices, coeff_shapes, output_format='wavedecn')</code>","text":"<p>Unravel a raveled array of multilevel wavelet coefficients.</p>"},{"location":"ref/#pywt.unravel_coeffs--parameters","title":"Parameters","text":"<p>arr : array-like     An array containing all wavelet coefficients. This should have been     generated by applying <code>ravel_coeffs</code> to the output of <code>wavedec</code>,     <code>wavedec2</code> or <code>wavedecn</code> (or via <code>swt</code>, <code>swt2</code> or <code>swtn</code>     with <code>trim_approx=True</code>). coeff_slices : list of tuples     List of slices corresponding to each coefficient as obtained from     <code>ravel_coeffs</code>. coeff_shapes : list of tuples     List of shapes corresponding to each coefficient as obtained from     <code>ravel_coeffs</code>. output_format : {'wavedec', 'wavedec2', 'wavedecn', 'swt', 'swt2', 'swtn'}, optional     Make the form of the unraveled coefficients compatible with this type     of multilevel transform. The default is <code>'wavedecn'</code>.</p>"},{"location":"ref/#pywt.unravel_coeffs--returns","title":"Returns","text":"<p>coeffs: list     List of wavelet transform coefficients. The specific format of the list     elements is determined by <code>output_format</code>.</p>"},{"location":"ref/#pywt.unravel_coeffs--see-also","title":"See Also","text":"<p>ravel_coeffs : the inverse of unravel_coeffs</p>"},{"location":"ref/#pywt.unravel_coeffs--examples","title":"Examples","text":"<p>import pywt from numpy.testing import assert_array_almost_equal cam = pywt.data.camera() coeffs = pywt.wavedecn(cam, wavelet='db2', level=3) arr, coeff_slices, coeff_shapes = pywt.ravel_coeffs(coeffs) coeffs_from_arr = pywt.unravel_coeffs(arr, coeff_slices, coeff_shapes, ...                                       output_format='wavedecn') cam_recon = pywt.waverecn(coeffs_from_arr, wavelet='db2') assert_array_almost_equal(cam, cam_recon)</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def unravel_coeffs(arr, coeff_slices, coeff_shapes, output_format='wavedecn'):\n    \"\"\"Unravel a raveled array of multilevel wavelet coefficients.\n\n    Parameters\n    ----------\n    arr : array-like\n        An array containing all wavelet coefficients. This should have been\n        generated by applying ``ravel_coeffs`` to the output of ``wavedec``,\n        ``wavedec2`` or ``wavedecn`` (or via ``swt``, ``swt2`` or ``swtn``\n        with ``trim_approx=True``).\n    coeff_slices : list of tuples\n        List of slices corresponding to each coefficient as obtained from\n        ``ravel_coeffs``.\n    coeff_shapes : list of tuples\n        List of shapes corresponding to each coefficient as obtained from\n        ``ravel_coeffs``.\n    output_format : {'wavedec', 'wavedec2', 'wavedecn', 'swt', 'swt2', 'swtn'}, optional\n        Make the form of the unraveled coefficients compatible with this type\n        of multilevel transform. The default is ``'wavedecn'``.\n\n    Returns\n    -------\n    coeffs: list\n        List of wavelet transform coefficients. The specific format of the list\n        elements is determined by ``output_format``.\n\n    See Also\n    --------\n    ravel_coeffs : the inverse of unravel_coeffs\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; from numpy.testing import assert_array_almost_equal\n    &gt;&gt;&gt; cam = pywt.data.camera()\n    &gt;&gt;&gt; coeffs = pywt.wavedecn(cam, wavelet='db2', level=3)\n    &gt;&gt;&gt; arr, coeff_slices, coeff_shapes = pywt.ravel_coeffs(coeffs)\n    &gt;&gt;&gt; coeffs_from_arr = pywt.unravel_coeffs(arr, coeff_slices, coeff_shapes,\n    ...                                       output_format='wavedecn')\n    &gt;&gt;&gt; cam_recon = pywt.waverecn(coeffs_from_arr, wavelet='db2')\n    &gt;&gt;&gt; assert_array_almost_equal(cam, cam_recon)\n\n    \"\"\"\n    arr = np.asarray(arr)\n    coeffs = []\n    if len(coeff_slices) == 0:\n        raise ValueError(\"empty list of coefficient slices\")\n    elif len(coeff_shapes) == 0:\n        raise ValueError(\"empty list of coefficient shapes\")\n    elif len(coeff_shapes) != len(coeff_slices):\n        raise ValueError(\"coeff_shapes and coeff_slices have unequal length\")\n    else:\n        coeffs.append(arr[coeff_slices[0]].reshape(coeff_shapes[0]))\n\n    # difference coefficients at each level\n    for n in range(1, len(coeff_slices)):\n        slice_dict = coeff_slices[n]\n        shape_dict = coeff_shapes[n]\n        if output_format in ['wavedec', 'swt']:\n            d = arr[slice_dict['d']].reshape(shape_dict['d'])\n        elif output_format in ['wavedec2', 'swt2']:\n            d = (arr[slice_dict['da']].reshape(shape_dict['da']),\n                 arr[slice_dict['ad']].reshape(shape_dict['ad']),\n                 arr[slice_dict['dd']].reshape(shape_dict['dd']))\n        elif output_format in ['wavedecn', 'swtn']:\n            d = {}\n            for k, v in coeff_slices[n].items():\n                d[k] = arr[v].reshape(shape_dict[k])\n        else:\n            raise ValueError(\n                f\"Unrecognized output format: {output_format}\")\n        coeffs.append(d)\n    return coeffs\n</code></pre>"},{"location":"ref/#pywt.upcoef","title":"<code>upcoef(part, coeffs, wavelet, level=1, take=0)</code>","text":"<p>upcoef(part, coeffs, wavelet, level=1, take=0)</p> <p>Direct reconstruction from coefficients.</p>"},{"location":"ref/#pywt.upcoef--parameters","title":"Parameters","text":"<p>part : str     Coefficients type:     * 'a' - approximations reconstruction is performed     * 'd' - details reconstruction is performed coeffs : array_like     Coefficients array to reconstruct wavelet : Wavelet object or name     Wavelet to use level : int, optional     Multilevel reconstruction level.  Default is 1. take : int, optional     Take central part of length equal to 'take' from the result.     Default is 0.</p>"},{"location":"ref/#pywt.upcoef--returns","title":"Returns","text":"<p>rec : ndarray     1-D array with reconstructed data from coefficients.</p>"},{"location":"ref/#pywt.upcoef--see-also","title":"See Also","text":"<p>downcoef</p>"},{"location":"ref/#pywt.upcoef--examples","title":"Examples","text":"<p>import pywt data = [1,2,3,4,5,6] (cA, cD) = pywt.dwt(data, 'db2', 'smooth') pywt.upcoef('a', cA, 'db2') + pywt.upcoef('d', cD, 'db2') array([-0.25      , -0.4330127 ,  1.        ,  2.        ,  3.        ,         4.        ,  5.        ,  6.        ,  1.78589838, -1.03108891]) n = len(data) pywt.upcoef('a', cA, 'db2', take=n) + pywt.upcoef('d', cD, 'db2', take=n) array([ 1.,  2.,  3.,  4.,  5.,  6.])</p> Source code in <code>pywt/_dwt.py</code> <pre><code>def upcoef(part, coeffs, wavelet, level=1, take=0):\n    \"\"\"\n    upcoef(part, coeffs, wavelet, level=1, take=0)\n\n    Direct reconstruction from coefficients.\n\n    Parameters\n    ----------\n    part : str\n        Coefficients type:\n        * 'a' - approximations reconstruction is performed\n        * 'd' - details reconstruction is performed\n    coeffs : array_like\n        Coefficients array to reconstruct\n    wavelet : Wavelet object or name\n        Wavelet to use\n    level : int, optional\n        Multilevel reconstruction level.  Default is 1.\n    take : int, optional\n        Take central part of length equal to 'take' from the result.\n        Default is 0.\n\n    Returns\n    -------\n    rec : ndarray\n        1-D array with reconstructed data from coefficients.\n\n    See Also\n    --------\n    downcoef\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; data = [1,2,3,4,5,6]\n    &gt;&gt;&gt; (cA, cD) = pywt.dwt(data, 'db2', 'smooth')\n    &gt;&gt;&gt; pywt.upcoef('a', cA, 'db2') + pywt.upcoef('d', cD, 'db2')\n    array([-0.25      , -0.4330127 ,  1.        ,  2.        ,  3.        ,\n            4.        ,  5.        ,  6.        ,  1.78589838, -1.03108891])\n    &gt;&gt;&gt; n = len(data)\n    &gt;&gt;&gt; pywt.upcoef('a', cA, 'db2', take=n) + pywt.upcoef('d', cD, 'db2', take=n)\n    array([ 1.,  2.,  3.,  4.,  5.,  6.])\n\n    \"\"\"\n    if not _have_c99_complex and np.iscomplexobj(coeffs):\n        return (upcoef(part, coeffs.real, wavelet, level, take) +\n                1j*upcoef(part, coeffs.imag, wavelet, level, take))\n    # accept array_like input; make a copy to ensure a contiguous array\n    dt = _check_dtype(coeffs)\n    coeffs = np.asarray(coeffs, dtype=dt, order='C')\n    if coeffs.ndim &gt; 1:\n        raise ValueError(\"upcoef only supports 1d coeffs.\")\n    wavelet = _as_wavelet(wavelet)\n    if part not in 'ad':\n        raise ValueError(f\"Argument 1 must be 'a' or 'd', not '{part}'.\")\n    return np.asarray(_upcoef(part == 'a', coeffs, wavelet, level, take))\n</code></pre>"},{"location":"ref/#pywt.wavedec","title":"<code>wavedec(data, wavelet, mode='symmetric', level=None, axis=-1)</code>","text":"<p>Multilevel 1D Discrete Wavelet Transform of data.</p>"},{"location":"ref/#pywt.wavedec--parameters","title":"Parameters","text":"<p>data: array_like     Input data wavelet : Wavelet object or name string     Wavelet to use mode : str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axis: int, optional     Axis over which to compute the DWT. If not given, the     last axis is used.</p>"},{"location":"ref/#pywt.wavedec--returns","title":"Returns","text":"<p>[cA_n, cD_n, cD_n-1, ..., cD2, cD1] : list     Ordered list of coefficients arrays     where <code>n</code> denotes the level of decomposition. The first element     (<code>cA_n</code>) of the result is approximation coefficients array and the     following elements (<code>cD_n</code> - <code>cD_1</code>) are details coefficients     arrays.</p>"},{"location":"ref/#pywt.wavedec--examples","title":"Examples","text":"<p>from pywt import wavedec coeffs = wavedec([1,2,3,4,5,6,7,8], 'db1', level=2) cA2, cD2, cD1 = coeffs cD1 array([-0.70710678, -0.70710678, -0.70710678, -0.70710678]) cD2 array([-2., -2.]) cA2 array([  5.,  13.])</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def wavedec(data, wavelet, mode='symmetric', level=None, axis=-1):\n    \"\"\"\n    Multilevel 1D Discrete Wavelet Transform of data.\n\n    Parameters\n    ----------\n    data: array_like\n        Input data\n    wavelet : Wavelet object or name string\n        Wavelet to use\n    mode : str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the ``dwt_max_level`` function.\n    axis: int, optional\n        Axis over which to compute the DWT. If not given, the\n        last axis is used.\n\n    Returns\n    -------\n    [cA_n, cD_n, cD_n-1, ..., cD2, cD1] : list\n        Ordered list of coefficients arrays\n        where ``n`` denotes the level of decomposition. The first element\n        (``cA_n``) of the result is approximation coefficients array and the\n        following elements (``cD_n`` - ``cD_1``) are details coefficients\n        arrays.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pywt import wavedec\n    &gt;&gt;&gt; coeffs = wavedec([1,2,3,4,5,6,7,8], 'db1', level=2)\n    &gt;&gt;&gt; cA2, cD2, cD1 = coeffs\n    &gt;&gt;&gt; cD1\n    array([-0.70710678, -0.70710678, -0.70710678, -0.70710678])\n    &gt;&gt;&gt; cD2\n    array([-2., -2.])\n    &gt;&gt;&gt; cA2\n    array([  5.,  13.])\n\n    \"\"\"\n    data = np.asarray(data)\n\n    wavelet = _as_wavelet(wavelet)\n    try:\n        axes_shape = data.shape[axis]\n    except IndexError:\n        raise AxisError(\"Axis greater than data dimensions\")\n    level = _check_level(axes_shape, wavelet.dec_len, level)\n\n    coeffs_list = []\n\n    a = data\n    for i in range(level):\n        a, d = dwt(a, wavelet, mode, axis)\n        coeffs_list.append(d)\n\n    coeffs_list.append(a)\n    coeffs_list.reverse()\n\n    return coeffs_list\n</code></pre>"},{"location":"ref/#pywt.wavedec2","title":"<code>wavedec2(data, wavelet, mode='symmetric', level=None, axes=(-2, -1))</code>","text":"<p>Multilevel 2D Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.wavedec2--parameters","title":"Parameters","text":"<p>data : ndarray     2D input data wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or 2-tuple of str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple containing a mode to apply along each axis in <code>axes</code>. level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axes : 2-tuple of ints, optional     Axes over which to compute the DWT. Repeated elements are not allowed.</p>"},{"location":"ref/#pywt.wavedec2--returns","title":"Returns","text":"<p>[cAn, (cHn, cVn, cDn), ... (cH1, cV1, cD1)] : list     Coefficients list.  For user-specified <code>axes</code>, <code>cH*</code>     corresponds to <code>axes[0]</code> while <code>cV*</code> corresponds to <code>axes[1]</code>.     The first element returned is the approximation coefficients for the     nth level of decomposition.  Remaining elements are tuples of detail     coefficients in descending order of decomposition level.     (i.e. <code>cH1</code> are the horizontal detail coefficients at the first     level)</p>"},{"location":"ref/#pywt.wavedec2--examples","title":"Examples","text":"<p>import pywt import numpy as np coeffs = pywt.wavedec2(np.ones((4,4)), 'db1')</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def wavedec2(data, wavelet, mode='symmetric', level=None, axes=(-2, -1)):\n    \"\"\"\n    Multilevel 2D Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    data : ndarray\n        2D input data\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or 2-tuple of str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple containing a mode to apply along each axis in ``axes``.\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the ``dwt_max_level`` function.\n    axes : 2-tuple of ints, optional\n        Axes over which to compute the DWT. Repeated elements are not allowed.\n\n    Returns\n    -------\n    [cAn, (cHn, cVn, cDn), ... (cH1, cV1, cD1)] : list\n        Coefficients list.  For user-specified ``axes``, ``cH*``\n        corresponds to ``axes[0]`` while ``cV*`` corresponds to ``axes[1]``.\n        The first element returned is the approximation coefficients for the\n        nth level of decomposition.  Remaining elements are tuples of detail\n        coefficients in descending order of decomposition level.\n        (i.e. ``cH1`` are the horizontal detail coefficients at the first\n        level)\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; coeffs = pywt.wavedec2(np.ones((4,4)), 'db1')\n    &gt;&gt;&gt; # Levels:\n    &gt;&gt;&gt; len(coeffs)-1\n    2\n    &gt;&gt;&gt; pywt.waverec2(coeffs, 'db1')\n    array([[ 1.,  1.,  1.,  1.],\n           [ 1.,  1.,  1.,  1.],\n           [ 1.,  1.,  1.,  1.],\n           [ 1.,  1.,  1.,  1.]])\n    \"\"\"\n    data = np.asarray(data)\n    if data.ndim &lt; 2:\n        raise ValueError(\"Expected input data to have at least 2 dimensions.\")\n\n    axes = tuple(axes)\n    if len(axes) != 2:\n        raise ValueError(\"Expected 2 axes\")\n    if len(axes) != len(set(axes)):\n        raise ValueError(\"The axes passed to wavedec2 must be unique.\")\n    try:\n        axes_sizes = [data.shape[ax] for ax in axes]\n    except IndexError:\n        raise AxisError(\"Axis greater than data dimensions\")\n\n    wavelets = _wavelets_per_axis(wavelet, axes)\n    dec_lengths = [w.dec_len for w in wavelets]\n\n    level = _check_level(axes_sizes, dec_lengths, level)\n\n    coeffs_list = []\n\n    a = data\n    for i in range(level):\n        a, ds = dwt2(a, wavelet, mode, axes)\n        coeffs_list.append(ds)\n\n    coeffs_list.append(a)\n    coeffs_list.reverse()\n\n    return coeffs_list\n</code></pre>"},{"location":"ref/#pywt.wavedec2--levels","title":"Levels:","text":"<p>len(coeffs)-1 2 pywt.waverec2(coeffs, 'db1') array([[ 1.,  1.,  1.,  1.],        [ 1.,  1.,  1.,  1.],        [ 1.,  1.,  1.,  1.],        [ 1.,  1.,  1.,  1.]])</p>"},{"location":"ref/#pywt.wavedecn","title":"<code>wavedecn(data, wavelet, mode='symmetric', level=None, axes=None)</code>","text":"<p>Multilevel nD Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.wavedecn--parameters","title":"Parameters","text":"<p>data : ndarray     nD input data wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or tuple of str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple containing a mode to apply along each axis in <code>axes</code>. level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axes : sequence of ints, optional     Axes over which to compute the DWT. Axes may not be repeated. The     default is None, which means transform all axes     (<code>axes = range(data.ndim)</code>).</p>"},{"location":"ref/#pywt.wavedecn--returns","title":"Returns","text":"<p>[cAn, {details_level_n}, ... {details_level_1}] : list     Coefficients list.  Coefficients are listed in descending order of     decomposition level.  <code>cAn</code> are the approximation coefficients at     level <code>n</code>.  Each <code>details_level_i</code> element is a dictionary     containing detail coefficients at level <code>i</code> of the decomposition. As     a concrete example, a 3D decomposition would have the following set of     keys in each <code>details_level_i</code> dictionary::</p> <pre><code>    {'aad', 'ada', 'daa', 'add', 'dad', 'dda', 'ddd'}\n\nwhere the order of the characters in each key map to the specified\n``axes``.\n</code></pre>"},{"location":"ref/#pywt.wavedecn--examples","title":"Examples","text":"<p>import numpy as np from pywt import wavedecn, waverecn coeffs = wavedecn(np.ones((4, 4, 4)), 'db1')</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def wavedecn(data, wavelet, mode='symmetric', level=None, axes=None):\n    \"\"\"\n    Multilevel nD Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    data : ndarray\n        nD input data\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or tuple of str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple containing a mode to apply along each axis in ``axes``.\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the ``dwt_max_level`` function.\n    axes : sequence of ints, optional\n        Axes over which to compute the DWT. Axes may not be repeated. The\n        default is None, which means transform all axes\n        (``axes = range(data.ndim)``).\n\n    Returns\n    -------\n    [cAn, {details_level_n}, ... {details_level_1}] : list\n        Coefficients list.  Coefficients are listed in descending order of\n        decomposition level.  ``cAn`` are the approximation coefficients at\n        level ``n``.  Each ``details_level_i`` element is a dictionary\n        containing detail coefficients at level ``i`` of the decomposition. As\n        a concrete example, a 3D decomposition would have the following set of\n        keys in each ``details_level_i`` dictionary::\n\n            {'aad', 'ada', 'daa', 'add', 'dad', 'dda', 'ddd'}\n\n        where the order of the characters in each key map to the specified\n        ``axes``.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pywt import wavedecn, waverecn\n    &gt;&gt;&gt; coeffs = wavedecn(np.ones((4, 4, 4)), 'db1')\n    &gt;&gt;&gt; # Levels:\n    &gt;&gt;&gt; len(coeffs)-1\n    2\n    &gt;&gt;&gt; waverecn(coeffs, 'db1')\n    array([[[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]],\n           [[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]],\n           [[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]],\n           [[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]]])\n\n    \"\"\"\n    data = np.asarray(data)\n    axes, axes_shapes, ndim_transform = _prep_axes_wavedecn(data.shape, axes)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n    dec_lengths = [w.dec_len for w in wavelets]\n\n    level = _check_level(axes_shapes, dec_lengths, level)\n\n    coeffs_list = []\n\n    a = data\n    for i in range(level):\n        coeffs = dwtn(a, wavelet, mode, axes)\n        a = coeffs.pop('a' * ndim_transform)\n        coeffs_list.append(coeffs)\n\n    coeffs_list.append(a)\n    coeffs_list.reverse()\n\n    return coeffs_list\n</code></pre>"},{"location":"ref/#pywt.wavedecn--levels","title":"Levels:","text":"<p>len(coeffs)-1 2 waverecn(coeffs, 'db1') array([[[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]]])</p>"},{"location":"ref/#pywt.wavedecn_shapes","title":"<code>wavedecn_shapes(shape, wavelet, mode='symmetric', level=None, axes=None)</code>","text":"<p>Subband shapes for a multilevel nD discrete wavelet transform.</p>"},{"location":"ref/#pywt.wavedecn_shapes--parameters","title":"Parameters","text":"<p>shape : sequence of ints     The shape of the data to be transformed. wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or tuple of str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple containing a mode to apply along each axis in <code>axes</code>. level : int, optional     Decomposition level (must be &gt;= 0). If level is None (default) then it     will be calculated using the <code>dwt_max_level</code> function. axes : sequence of ints, optional     Axes over which to compute the DWT. Axes may not be repeated. The     default is None, which means transform all axes     (<code>axes = range(data.ndim)</code>).</p>"},{"location":"ref/#pywt.wavedecn_shapes--returns","title":"Returns","text":"<p>shapes : [cAn, {details_level_n}, ... {details_level_1}] : list     Coefficients shape list.  Mirrors the output of <code>wavedecn</code>, except     it contains only the shapes of the coefficient arrays rather than the     arrays themselves.</p>"},{"location":"ref/#pywt.wavedecn_shapes--examples","title":"Examples","text":"<p>import pywt pywt.wavedecn_shapes((64, 32), wavelet='db2', level=3, axes=(0, )) [(10, 32), {'d': (10, 32)}, {'d': (18, 32)}, {'d': (33, 32)}]</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def wavedecn_shapes(shape, wavelet, mode='symmetric', level=None, axes=None):\n    \"\"\"Subband shapes for a multilevel nD discrete wavelet transform.\n\n    Parameters\n    ----------\n    shape : sequence of ints\n        The shape of the data to be transformed.\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or tuple of str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple containing a mode to apply along each axis in ``axes``.\n    level : int, optional\n        Decomposition level (must be &gt;= 0). If level is None (default) then it\n        will be calculated using the ``dwt_max_level`` function.\n    axes : sequence of ints, optional\n        Axes over which to compute the DWT. Axes may not be repeated. The\n        default is None, which means transform all axes\n        (``axes = range(data.ndim)``).\n\n    Returns\n    -------\n    shapes : [cAn, {details_level_n}, ... {details_level_1}] : list\n        Coefficients shape list.  Mirrors the output of ``wavedecn``, except\n        it contains only the shapes of the coefficient arrays rather than the\n        arrays themselves.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; pywt.wavedecn_shapes((64, 32), wavelet='db2', level=3, axes=(0, ))\n    [(10, 32), {'d': (10, 32)}, {'d': (18, 32)}, {'d': (33, 32)}]\n    \"\"\"\n    axes, axes_shapes, ndim_transform = _prep_axes_wavedecn(shape, axes)\n    wavelets = _wavelets_per_axis(wavelet, axes)\n    modes = _modes_per_axis(mode, axes)\n    dec_lengths = [w.dec_len for w in wavelets]\n\n    level = _check_level(min(axes_shapes), max(dec_lengths), level)\n\n    shapes = []\n    for i in range(level):\n        detail_keys = [''.join(c) for c in product('ad', repeat=len(axes))]\n        new_shapes = {k: list(shape) for k in detail_keys}\n        for axis, wav, mode in zip(axes, wavelets, modes):\n            s = dwt_coeff_len(shape[axis], filter_len=wav.dec_len, mode=mode)\n            for k in detail_keys:\n                new_shapes[k][axis] = s\n        for k, v in new_shapes.items():\n            new_shapes[k] = tuple(v)\n        shapes.append(new_shapes)\n        shape = new_shapes.pop('a' * ndim_transform)\n    shapes.append(shape)\n    shapes.reverse()\n    return shapes\n</code></pre>"},{"location":"ref/#pywt.wavedecn_size","title":"<code>wavedecn_size(shapes)</code>","text":"<p>Compute the total number of wavedecn coefficients.</p>"},{"location":"ref/#pywt.wavedecn_size--parameters","title":"Parameters","text":"<p>shapes : list of coefficient shapes     A set of coefficient shapes as returned by <code>wavedecn_shapes</code>.     Alternatively, the user can specify a set of coefficients as returned     by <code>wavedecn</code>.</p>"},{"location":"ref/#pywt.wavedecn_size--returns","title":"Returns","text":"<p>size : int     The total number of coefficients.</p>"},{"location":"ref/#pywt.wavedecn_size--examples","title":"Examples","text":"<p>import numpy as np import pywt data_shape = (64, 32) shapes = pywt.wavedecn_shapes(data_shape, 'db2', mode='periodization') pywt.wavedecn_size(shapes) 2048 coeffs = pywt.wavedecn(np.ones(data_shape), 'sym4', mode='symmetric') pywt.wavedecn_size(coeffs) 3087</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def wavedecn_size(shapes):\n    \"\"\"Compute the total number of wavedecn coefficients.\n\n    Parameters\n    ----------\n    shapes : list of coefficient shapes\n        A set of coefficient shapes as returned by ``wavedecn_shapes``.\n        Alternatively, the user can specify a set of coefficients as returned\n        by ``wavedecn``.\n\n    Returns\n    -------\n    size : int\n        The total number of coefficients.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; data_shape = (64, 32)\n    &gt;&gt;&gt; shapes = pywt.wavedecn_shapes(data_shape, 'db2', mode='periodization')\n    &gt;&gt;&gt; pywt.wavedecn_size(shapes)\n    2048\n    &gt;&gt;&gt; coeffs = pywt.wavedecn(np.ones(data_shape), 'sym4', mode='symmetric')\n    &gt;&gt;&gt; pywt.wavedecn_size(coeffs)\n    3087\n    \"\"\"\n    def _size(x):\n        \"\"\"Size corresponding to ``x`` as either a shape tuple or ndarray.\"\"\"\n        if isinstance(x, np.ndarray):\n            return x.size\n        else:\n            return np.prod(x)\n    ncoeffs = _size(shapes[0])\n    for d in shapes[1:]:\n        for k, v in d.items():\n            if v is None:\n                raise ValueError(\n                    \"Setting coefficient arrays to None is not supported.\")\n            ncoeffs += _size(v)\n    return ncoeffs\n</code></pre>"},{"location":"ref/#pywt.waverec","title":"<code>waverec(coeffs, wavelet, mode='symmetric', axis=-1)</code>","text":"<p>Multilevel 1D Inverse Discrete Wavelet Transform.</p>"},{"location":"ref/#pywt.waverec--parameters","title":"Parameters","text":"<p>coeffs : array_like     Coefficients list [cAn, cDn, cDn-1, ..., cD2, cD1] wavelet : Wavelet object or name string     Wavelet to use mode : str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. axis: int, optional     Axis over which to compute the inverse DWT. If not given, the     last axis is used.</p>"},{"location":"ref/#pywt.waverec--notes","title":"Notes","text":"<p>It may sometimes be desired to run <code>waverec</code> with some sets of coefficients omitted.  This can best be done by setting the corresponding arrays to zero arrays of matching shape and dtype.  Explicitly removing list entries or setting them to None is not supported.</p> <p>Specifically, to ignore detail coefficients at level 2, one could do::</p> <pre><code>coeffs[-2] = np.zeros_like(coeffs[-2])\n</code></pre>"},{"location":"ref/#pywt.waverec--examples","title":"Examples","text":"<p>import pywt coeffs = pywt.wavedec([1,2,3,4,5,6,7,8], 'db1', level=2) pywt.waverec(coeffs, 'db1') array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def waverec(coeffs, wavelet, mode='symmetric', axis=-1):\n    \"\"\"\n    Multilevel 1D Inverse Discrete Wavelet Transform.\n\n    Parameters\n    ----------\n    coeffs : array_like\n        Coefficients list [cAn, cDn, cDn-1, ..., cD2, cD1]\n    wavelet : Wavelet object or name string\n        Wavelet to use\n    mode : str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`.\n    axis: int, optional\n        Axis over which to compute the inverse DWT. If not given, the\n        last axis is used.\n\n    Notes\n    -----\n    It may sometimes be desired to run ``waverec`` with some sets of\n    coefficients omitted.  This can best be done by setting the corresponding\n    arrays to zero arrays of matching shape and dtype.  Explicitly removing\n    list entries or setting them to None is not supported.\n\n    Specifically, to ignore detail coefficients at level 2, one could do::\n\n        coeffs[-2] = np.zeros_like(coeffs[-2])\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; coeffs = pywt.wavedec([1,2,3,4,5,6,7,8], 'db1', level=2)\n    &gt;&gt;&gt; pywt.waverec(coeffs, 'db1')\n    array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n    \"\"\"\n\n    if not isinstance(coeffs, (list, tuple)):\n        raise ValueError(\"Expected sequence of coefficient arrays.\")\n\n    if len(coeffs) &lt; 1:\n        raise ValueError(\n            \"Coefficient list too short (minimum 1 arrays required).\")\n    elif len(coeffs) == 1:\n        # level 0 transform (just returns the approximation coefficients)\n        return coeffs[0]\n\n    a, ds = coeffs[0], coeffs[1:]\n\n    for d in ds:\n        if d is not None and not isinstance(d, np.ndarray):\n            raise ValueError(\n                f\"Unexpected detail coefficient type: {type(d)}. Detail coefficients \"\n                \"must be arrays as returned by wavedec. If you are using \"\n                \"pywt.array_to_coeffs or pywt.unravel_coeffs, please specify \"\n                \"output_format='wavedec'\")\n        if (a is not None) and (d is not None):\n            try:\n                if a.shape[axis] == d.shape[axis] + 1:\n                    a = a[tuple(slice(s) for s in d.shape)]\n                elif a.shape[axis] != d.shape[axis]:\n                    raise ValueError(\"coefficient shape mismatch\")\n            except IndexError:\n                raise AxisError(\"Axis greater than coefficient dimensions\")\n        a = idwt(a, d, wavelet, mode, axis)\n\n    return a\n</code></pre>"},{"location":"ref/#pywt.waverec2","title":"<code>waverec2(coeffs, wavelet, mode='symmetric', axes=(-2, -1))</code>","text":"<p>Multilevel 2D Inverse Discrete Wavelet Transform.</p> list or tuple <p>Coefficients list [cAn, (cHn, cVn, cDn), ... (cH1, cV1, cD1)]</p> <p>wavelet : Wavelet object or name string, or 2-tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or 2-tuple of str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple containing a mode to apply along each axis in <code>axes</code>. axes : 2-tuple of ints, optional     Axes over which to compute the IDWT. Repeated elements are not allowed.</p>"},{"location":"ref/#pywt.waverec2--returns","title":"Returns","text":"<p>2D array of reconstructed data.</p>"},{"location":"ref/#pywt.waverec2--notes","title":"Notes","text":"<p>It may sometimes be desired to run <code>waverec2</code> with some sets of coefficients omitted.  This can best be done by setting the corresponding arrays to zero arrays of matching shape and dtype.  Explicitly removing list or tuple entries or setting them to None is not supported.</p> <p>Specifically, to ignore all detail coefficients at level 2, one could do::</p> <pre><code>coeffs[-2] == tuple([np.zeros_like(v) for v in coeffs[-2]])\n</code></pre>"},{"location":"ref/#pywt.waverec2--examples","title":"Examples","text":"<p>import pywt import numpy as np coeffs = pywt.wavedec2(np.ones((4,4)), 'db1')</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def waverec2(coeffs, wavelet, mode='symmetric', axes=(-2, -1)):\n    \"\"\"\n    Multilevel 2D Inverse Discrete Wavelet Transform.\n\n    coeffs : list or tuple\n        Coefficients list [cAn, (cHn, cVn, cDn), ... (cH1, cV1, cD1)]\n    wavelet : Wavelet object or name string, or 2-tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or 2-tuple of str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple containing a mode to apply along each axis in ``axes``.\n    axes : 2-tuple of ints, optional\n        Axes over which to compute the IDWT. Repeated elements are not allowed.\n\n    Returns\n    -------\n    2D array of reconstructed data.\n\n    Notes\n    -----\n    It may sometimes be desired to run ``waverec2`` with some sets of\n    coefficients omitted.  This can best be done by setting the corresponding\n    arrays to zero arrays of matching shape and dtype.  Explicitly removing\n    list or tuple entries or setting them to None is not supported.\n\n    Specifically, to ignore all detail coefficients at level 2, one could do::\n\n        coeffs[-2] == tuple([np.zeros_like(v) for v in coeffs[-2]])\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pywt\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; coeffs = pywt.wavedec2(np.ones((4,4)), 'db1')\n    &gt;&gt;&gt; # Levels:\n    &gt;&gt;&gt; len(coeffs)-1\n    2\n    &gt;&gt;&gt; pywt.waverec2(coeffs, 'db1')\n    array([[ 1.,  1.,  1.,  1.],\n           [ 1.,  1.,  1.,  1.],\n           [ 1.,  1.,  1.,  1.],\n           [ 1.,  1.,  1.,  1.]])\n    \"\"\"\n    if not isinstance(coeffs, (list, tuple)):\n        raise ValueError(\"Expected sequence of coefficient arrays.\")\n\n    if len(axes) != len(set(axes)):\n        raise ValueError(\"The axes passed to waverec2 must be unique.\")\n\n    if len(coeffs) &lt; 1:\n        raise ValueError(\n            \"Coefficient list too short (minimum 1 array required).\")\n    elif len(coeffs) == 1:\n        # level 0 transform (just returns the approximation coefficients)\n        return coeffs[0]\n\n    a, ds = coeffs[0], coeffs[1:]\n    a = np.asarray(a)\n\n    for d in ds:\n        if not isinstance(d, (list, tuple)) or len(d) != 3:\n            raise ValueError(\n                f\"Unexpected detail coefficient type: {type(d)}. Detail coefficients \"\n                \"must be a 3-tuple of arrays as returned by wavedec2. If you \"\n                \"are using pywt.array_to_coeffs or pywt.unravel_coeffs, \"\n                \"please specify output_format='wavedec2'\")\n        d = tuple(np.asarray(coeff) if coeff is not None else None\n                  for coeff in d)\n        d_shapes = (coeff.shape for coeff in d if coeff is not None)\n        try:\n            d_shape = next(d_shapes)\n        except StopIteration:\n            idxs = slice(None), slice(None)\n        else:\n            if not all(s == d_shape for s in d_shapes):\n                raise ValueError(\"All detail shapes must be the same length.\")\n            idxs = tuple(slice(None, -1 if a_len == d_len + 1 else None)\n                         for a_len, d_len in zip(a.shape, d_shape))\n        a = idwt2((a[idxs], d), wavelet, mode, axes)\n\n    return a\n</code></pre>"},{"location":"ref/#pywt.waverec2--levels","title":"Levels:","text":"<p>len(coeffs)-1 2 pywt.waverec2(coeffs, 'db1') array([[ 1.,  1.,  1.,  1.],        [ 1.,  1.,  1.,  1.],        [ 1.,  1.,  1.,  1.],        [ 1.,  1.,  1.,  1.]])</p>"},{"location":"ref/#pywt.waverecn","title":"<code>waverecn(coeffs, wavelet, mode='symmetric', axes=None)</code>","text":"<p>Multilevel nD Inverse Discrete Wavelet Transform.</p> array_like <p>Coefficients list [cAn, {details_level_n}, ... {details_level_1}]</p> <p>wavelet : Wavelet object or name string, or tuple of wavelets     Wavelet to use.  This can also be a tuple containing a wavelet to     apply along each axis in <code>axes</code>. mode : str or tuple of str, optional     Signal extension mode, see :ref:<code>Modes &lt;ref-modes&gt;</code>. This can     also be a tuple containing a mode to apply along each axis in <code>axes</code>. axes : sequence of ints, optional     Axes over which to compute the IDWT.  Axes may not be repeated.</p>"},{"location":"ref/#pywt.waverecn--returns","title":"Returns","text":"<p>nD array of reconstructed data.</p>"},{"location":"ref/#pywt.waverecn--notes","title":"Notes","text":"<p>It may sometimes be desired to run <code>waverecn</code> with some sets of coefficients omitted.  This can best be done by setting the corresponding arrays to zero arrays of matching shape and dtype.  Explicitly removing list or dictionary entries or setting them to None is not supported.</p> <p>Specifically, to ignore all detail coefficients at level 2, one could do::</p> <pre><code>coeffs[-2] = {k: np.zeros_like(v) for k, v in coeffs[-2].items()}\n</code></pre>"},{"location":"ref/#pywt.waverecn--examples","title":"Examples","text":"<p>import numpy as np from pywt import wavedecn, waverecn coeffs = wavedecn(np.ones((4, 4, 4)), 'db1')</p> Source code in <code>pywt/_multilevel.py</code> <pre><code>def waverecn(coeffs, wavelet, mode='symmetric', axes=None):\n    \"\"\"\n    Multilevel nD Inverse Discrete Wavelet Transform.\n\n    coeffs : array_like\n        Coefficients list [cAn, {details_level_n}, ... {details_level_1}]\n    wavelet : Wavelet object or name string, or tuple of wavelets\n        Wavelet to use.  This can also be a tuple containing a wavelet to\n        apply along each axis in ``axes``.\n    mode : str or tuple of str, optional\n        Signal extension mode, see :ref:`Modes &lt;ref-modes&gt;`. This can\n        also be a tuple containing a mode to apply along each axis in ``axes``.\n    axes : sequence of ints, optional\n        Axes over which to compute the IDWT.  Axes may not be repeated.\n\n    Returns\n    -------\n    nD array of reconstructed data.\n\n    Notes\n    -----\n    It may sometimes be desired to run ``waverecn`` with some sets of\n    coefficients omitted.  This can best be done by setting the corresponding\n    arrays to zero arrays of matching shape and dtype.  Explicitly removing\n    list or dictionary entries or setting them to None is not supported.\n\n    Specifically, to ignore all detail coefficients at level 2, one could do::\n\n        coeffs[-2] = {k: np.zeros_like(v) for k, v in coeffs[-2].items()}\n\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pywt import wavedecn, waverecn\n    &gt;&gt;&gt; coeffs = wavedecn(np.ones((4, 4, 4)), 'db1')\n    &gt;&gt;&gt; # Levels:\n    &gt;&gt;&gt; len(coeffs)-1\n    2\n    &gt;&gt;&gt; waverecn(coeffs, 'db1')\n    array([[[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]],\n           [[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]],\n           [[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]],\n           [[ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.],\n            [ 1.,  1.,  1.,  1.]]])\n\n    \"\"\"\n    if len(coeffs) &lt; 1:\n        raise ValueError(\n            \"Coefficient list too short (minimum 1 array required).\")\n\n    a, ds = coeffs[0], coeffs[1:]\n\n    # this dictionary check must be prior to the call to _fix_coeffs\n    if len(ds) &gt; 0 and not all(isinstance(d, dict) for d in ds):\n        raise ValueError(\n            f\"Unexpected detail coefficient type: {type(ds[0])}. Detail coefficients \"\n            \"must be a dictionary of arrays as returned by wavedecn. If \"\n            \"you are using pywt.array_to_coeffs or pywt.unravel_coeffs, \"\n            \"please specify output_format='wavedecn'\")\n\n    # Raise error for invalid key combinations\n    ds = list(map(_fix_coeffs, ds))\n\n    if not ds:\n        # level 0 transform (just returns the approximation coefficients)\n        return coeffs[0]\n    if a is None and not any(ds):\n        raise ValueError(\n            \"At least one coefficient must contain a valid value.\")\n\n    coeff_ndims = []\n    if a is not None:\n        a = np.asarray(a)\n        coeff_ndims.append(a.ndim)\n    for d in ds:\n        coeff_ndims += [v.ndim for k, v in d.items()]\n\n    # test that all coefficients have a matching number of dimensions\n    unique_coeff_ndims = np.unique(coeff_ndims)\n    if len(unique_coeff_ndims) == 1:\n        ndim = unique_coeff_ndims[0]\n    else:\n        raise ValueError(\n            \"All coefficients must have a matching number of dimensions\")\n\n    if np.isscalar(axes):\n        axes = (axes, )\n    if axes is None:\n        axes = range(ndim)\n    else:\n        axes = tuple(axes)\n    if len(axes) != len(set(axes)):\n        raise ValueError(\"The axes passed to waverecn must be unique.\")\n    ndim_transform = len(axes)\n\n    for idx, d in enumerate(ds):\n        if a is None and not d:\n            continue\n        # The following if statement handles the case where the approximation\n        # coefficient returned at the previous level may exceed the size of the\n        # stored detail coefficients by 1 on any given axis.\n        if idx &gt; 0:\n            a = _match_coeff_dims(a, d)\n        d['a' * ndim_transform] = a\n        a = idwtn(d, wavelet, mode, axes)\n\n    return a\n</code></pre>"},{"location":"ref/#pywt.waverecn--levels","title":"Levels:","text":"<p>len(coeffs)-1 2 waverecn(coeffs, 'db1') array([[[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]],        [[ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.],         [ 1.,  1.,  1.,  1.]]])</p>"}]}